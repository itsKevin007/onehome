<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>OpenCV: ICP point-to-plane odometry algorithm</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
//<![CDATA[
window.MathJax = {
    loader: {load: ['[tex]/ams']},
    tex: {
        packages: {'[+]': ['ams']},
        macros: {
            matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
            fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
            forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
            forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
            vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
            vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
            cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
            distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
            distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
            hdotsfor: ["\\dots", 1],
            mathbbm: ["\\mathbb{#1}", 1],
            bordermatrix: ["\\matrix{#1}", 1]
        },
        processEscapes: false
    }
};
//]]>
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.10.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">ICP point-to-plane odometry algorithm</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This article describes an ICP algorithm used in depth fusion pipelines such as KinectFusion.</p>
<p>The goal of ICP is to align two point clouds, the old one (the existing points and normals in 3D model) and new one (new points and normals, what we want to integrate to the exising model). ICP returns rotation+translation transform between these two point clouds.</p>
<p>The Iterative Closest Point (ICP) minimizes the objective function which is the Point to Plane Distance (PPD) between the corresponding points in two point clouds:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=E=\sum_{i}\left\|ppd(p_{i}, q_{i}, n_{i})\right\|_{2}\rightarrow0" alt="" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md196"></a>
What is ppd(p, q, n)?</h2>
<p>Specifically, for each corresponding points <em><b>P</b></em> and <em><b>Q</b></em>, it is the distance from the point <em><b>P</b></em> to the plane determined by the point <em><b>Q</b></em> and the normal <em><b>N</b></em> located in the point <em><b>Q</b></em>. Two points <em><b>P</b></em> and <em><b>Q</b></em> are considered correspondent if given current camera pose they are projected in the same pixel.</p>
<p><em><b>p</b></em> - i'th point in the new point cloud</p>
<p><em><b>q</b></em> - i'th point in the old point cloud</p>
<p><em><b>n</b></em> - normal in the point <em><b>q</b></em> in the old point cloud</p>
<p>Therefore, <em><b>ppd(...)</b></em> can be expressed as the dot product of (difference between <em><b>p</b></em> and <em><b>q</b></em>) and (<em><b>n</b></em>):</p>
<p><img src="https://render.githubusercontent.com/render/math?math=dot(T_{p2q}(p)-q, n)=dot((R\cdot p %2b t)-q,n)=[(R\cdot p %2b t)-q]^{T}\cdot n" alt="" class="inline"/></p>
<p><em><b>T(p)</b></em> is a rigid transform of point <em><b>p</b></em>:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=T_{p2q}(p) = (R \cdot  p %2B t)" alt="" class="inline"/></p>
<p>where <em><b>R</b></em> - rotation, <em><b>t</b></em> - translation.</p>
<p><em><b>T</b></em> is the transform we search by ICP, its purpose is to bring each point <em><b>p</b></em> closer to the corresponding point <em><b>q</b></em> in terms of point to plane distance.</p>
<h2><a class="anchor" id="autotoc_md197"></a>
How to minimize objective function?</h2>
<p>We use the Gauss-Newton method for the function minimization.</p>
<p>In Gauss-Newton method we do sequential steps by changing <em><b>R</b></em> and <em><b>t</b></em> in the direction of the function E decrease, i.e. in the direction of its gradient:</p>
<ol type="1">
<li>At each step we approximate the function <em><b>E</b></em> linearly as its current value plus Jacobian matrix multiplied by <em><b>delta x</b></em> which is concatenated <em><b>delta R</b></em> and <em><b>delta t</b></em> vectors.</li>
<li>We find <em><b>delta R</b></em> and <em><b>delta t</b></em> by solving the equation <em><b>E_approx(delta_x) = 0</b></em></li>
<li>We apply <em><b>delta R</b></em> and <em><b>delta t</b></em> to current Rt transform and proceed to next iteration</li>
</ol>
<h2><a class="anchor" id="autotoc_md198"></a>
How to linearize E?</h2>
<p>Let's approximate it in infinitesimal neighborhood.</p>
<p>Here's a formula we're going to minimize by changing <em><b>R</b></em> and <em><b>t</b></em>:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=E=\sum\left\|[(R\cdot p %2B t)-q]^{T}\cdot n\right\|_{2}" alt="" class="inline"/></p>
<p>While the point to plane distance is linear to both <em><b>R</b></em> and <em><b>t</b></em>, the rotation space is not linear by itself. You can see this in how <em><b>R</b></em> is generated from its rotation angles:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+R+%3D+R_%7Bz%7D%28%5Cgamma%29R_%7By%7D%28%5Cbeta+%29R_%7Bx%7D%28%5Calpha%29%3D%0A%5Cbegin%7Bbmatrix%7D%0Acos%28%5Cgamma%29+%26+-sin%28%5Cgamma%29+%26+0+%5C%5C%0Asin%28%5Cgamma%29+%26+cos%28%5Cgamma%29+%26+0%5C%5C%0A0+%26+0+%26+1%0A%5Cend%7Bbmatrix%7D%0A%5Cbegin%7Bbmatrix%7D%0Acos%28%5Cbeta%29+%26+0+%26+sin%28%5Cbeta%29%5C%5C%0A0+%26+1+%26+0%5C%5C%0A-sin%28%5Cbeta%29+%26+0+%26+cos%28%5Cbeta%29%0A%5Cend%7Bbmatrix%7D%0A%5Cbegin%7Bbmatrix%7D%0A1+%26+0+%26+0%5C%5C%0A0+%26+cos%28%5Calpha%29+%26+-sin%28%5Calpha%29%5C%5C%0A0+%26+sin%28%5Calpha%29+%26+cos%28%5Calpha%29%0A%5Cend%7Bbmatrix%7D%0A" alt="" class="inline"/></p>
<p>But since we have infinitesimal rotations, <em><b>R</b></em> can be approximated in the following form:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=R=I %2B Ad\theta" alt="" class="inline"/></p>
<p>where <em><b>I</b></em> - unit matrix, <em><b>A</b></em> - member of the three-dimensional special orthogonal group <em><b>so(3)</b></em>.</p>
<p>By approaching all sin(t) and cos(t) terms to their limits where <em><b>t --&gt; 0</b></em> we get the following representation:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=R = I %2B \begin{bmatrix}0 %26 -\gamma  %26 \beta \\ \gamma %26 0 %26 -\alpha \\ -\beta  %26 \alpha  %26 0 \end{bmatrix} = I %2B skew(\begin{bmatrix} \alpha %26 \beta %26 \gamma \end{bmatrix}^{T}) = I %2B skew(R_{shift}) " alt="" class="inline"/></p>
<p>Substituting the approximation of <em><b>R</b></em> back into <em><b>E</b></em> expression, we get:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=E_{approx}=\sum\left\|[(I %2B skew(R_{shift})) \cdot  p %2B t - q]^{T}  \cdot n \right \|_{2} " alt="" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=E_{approx} = \sum \left \| [I \cdot  p %2B skew(R_{shift}) \cdot  p %2B t - q]^{T}  \cdot n \right \|_{2} " alt="" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=E_{approx} = \sum \left \| [skew(R_{shift}) \cdot  p %2B t %2B p- q]^{T}  \cdot n \right \|_{2} " alt="" class="inline"/></p>
<p>Let's introduce a function f which approximates transform shift:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=f(x, p) = skew(R_{shift}) \cdot  p %2B t" alt="" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=E_{approx} = \sum \left \| [f(x, p) %2B p- q]^{T}  \cdot n \right \|_{2}" alt="" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md199"></a>
How to minimize &lt;em&gt;E_approx&lt;/em&gt;?</h2>
<p><em><b>E_approx</b></em> is minimal when its differential (i.e. derivative by argument increase) is zero, so let's find that differential:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=d(E_{approx}) = \sum_i d(\left \| ppd(T_{approx}(p_i), q_i, n_i) \right \|_2) = " alt="" class="inline"/> <img src="https://render.githubusercontent.com/render/math?math=\sum_i d(ppd(T_{approx}(p_i), q_i, n_i)^2) =" alt="" class="inline"/> <img src="https://render.githubusercontent.com/render/math?math=\sum_i 2\cdot ppd(...)\cdot d(ppd(T_{approx}(p_i), q_i, n_i))" alt="" class="inline"/></p>
<p>Let's differentiate <em><b>ppd</b></em>:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=d(ppd(T_{approx}(p_i), q_i, n_i)) = d([f(x, p_i) %2b p_i- q_i]^{T}  \cdot n_i) = df(x, p_i)^{T}  \cdot n_i = dx^T f&#39;(x, p_i)^T \cdot n_i" alt="" class="inline"/></p>
<p>Here's what we get for all variables x_j from vector x:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=\frac{\partial E}{\partial x_{j}} = \sum [2 \cdot (f(x, p) %2B p - q)^{T} \cdot n] \cdot [f_{j}&#39;(x, p)^{T} \cdot n] = 0" alt="" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\sum [2 \cdot n^{T} \cdot (f(x, p) %2B p - q)] \cdot [n^{T} \cdot f{}&#39;(x, p)] = 0 " alt="" class="inline"/></p>
<p>Let new variable: <img src="https://render.githubusercontent.com/render/math?math=\triangle p = p - q" alt="" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\sum [2 \cdot n^{T} \cdot (f(x, p) %2B \triangle p)] \cdot [n^{T} \cdot f{}&#39;(x, p)] = 0" alt="" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\sum [(f(x, p) %2B \triangle p)^{T} \cdot (n \cdot n^{T})] \cdot f{}&#39;(x, p) = 0" alt="" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\sum f{}&#39;(x, p)^{T} \cdot [n \cdot n^{T}] \cdot [f(x, p) %2B \triangle p] = 0" alt="" class="inline"/></p>
<p><em><b>f(x, p)</b></em> can be represented as a matrix-vector multiplication. To prove that, we have to remember that <img src="https://render.githubusercontent.com/render/math?math=cross(a, b) = skew(a) \cdot b = skew(b)^{T} \cdot a" alt="" class="inline"/> :</p>
<p><img src="https://render.githubusercontent.com/render/math?math=f(x, p) = skew(R_{shift}) \cdot  p %2B t_{shift} = skew(p)^T R_{shift} %2B t_{shift}" alt="" class="inline"/> <img src="https://render.githubusercontent.com/render/math?math=f(x, p) = \begin{bmatrix} skew(p)^{T} %26 I_{3\times 3}\end{bmatrix} \cdot \begin{bmatrix} \triangle R %26 \triangle t \end{bmatrix}^{T} = G(p) \cdot x" alt="" class="inline"/></p>
<p><em><b>G(p)</b></em> is introduced for simplification.</p>
<p>Since <img src="https://render.githubusercontent.com/render/math?math=d(f(x, p)) = G(p) \cdot dx = f&#39;(x, p) \cdot dx" alt="" class="inline"/> we get <img src="https://render.githubusercontent.com/render/math?math=f&#39;(x, p) = G(p)" alt="" class="inline"/>.</p>
<p><img src="https://render.githubusercontent.com/render/math?math=\sum f{}&#39;(x, p)^{T} \cdot [n \cdot n^{T}] \cdot [f(x, p)] = \sum f{}&#39;(x, p)^{T} \cdot [n \cdot n^{T}] \cdot [- \triangle p]" alt="" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\sum G(p)^{T} \cdot [n \cdot n^{T}] \cdot [G(p) \cdot X] = \sum G(p)^{T} \cdot [n \cdot n^{T}] \cdot [- \triangle p]" alt="" class="inline"/></p>
<p>Let a new value:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=C = G(p)^{T} \cdot n" alt="" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=C^{T} = (G(p)^{T} \cdot n)^{T} = n^{T} \cdot G(p)" alt="" class="inline"/></p>
<p>Let's make a replacement:</p>
<p><img src="https://render.githubusercontent.com/render/math?math=\sum C \cdot C^{T} \cdot X = \sum C \cdot n^{T} \cdot [- \triangle p]" alt="" class="inline"/></p>
<p><img src="https://render.githubusercontent.com/render/math?math=\sum C\cdot C^{T}\cdot \begin{bmatrix} \triangle R\\ \triangle t \end{bmatrix} = \sum C \cdot n^{T} \cdot [- \triangle p]" alt="" class="inline"/></p>
<p>By solving this equation we get rigid transform shift for each Gauss-Newton iteration.</p>
<h2><a class="anchor" id="autotoc_md200"></a>
How do we apply transform shift?</h2>
<p>We generate rotation and translation matrix from the shift and then multiply the current pose matrix by the one we've got.</p>
<p>While the translational part of the shift contributes to the resulting matrix as-is, the rotational part is generated a bit trickier. The rotation shift is converted from <em><b>so(3)</b></em> to <em><b>SO(3)</b></em> by exponentiation. In fact, the 3-by-1 rshift vector represents rotation axis multiplied by the rotation angle. We use Rodrigues transform to get rotation matrix from that. For more details, see <a href="https://en.wikipedia.org/wiki/3D_rotation_group" target="_blank">wiki page</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 2 2024 21:52:13 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.9.8
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
