<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>OpenCV: Smoothing Images</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
//<![CDATA[
window.MathJax = {
    loader: {load: ['[tex]/ams']},
    tex: {
        packages: {'[+]': ['ams']},
        macros: {
            matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
            fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
            forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
            forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
            vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
            vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
            cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
            distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
            distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
            hdotsfor: ["\\dots", 1],
            mathbbm: ["\\mathbb{#1}", 1],
            bordermatrix: ["\\matrix{#1}", 1]
        },
        processEscapes: false
    }
};
//]]>
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.10.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d6/d00/tutorial_py_root.html">OpenCV-Python Tutorials</a></li><li class="navelem"><a class="el" href="../../d2/d96/tutorial_py_table_of_contents_imgproc.html">Image Processing in OpenCV</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Smoothing Images</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1360"></a>
Goals</h1>
<p>Learn to:</p><ul>
<li>Blur images with various low pass filters</li>
<li>Apply custom-made filters to images (2D convolution)</li>
</ul>
<h1><a class="anchor" id="autotoc_md1361"></a>
2D Convolution ( Image Filtering )</h1>
<p>As in one-dimensional signals, images also can be filtered with various low-pass filters (LPF), high-pass filters (HPF), etc. LPF helps in removing noise, blurring images, etc. HPF filters help in finding edges in images.</p>
<p>OpenCV provides a function <b><a class="el" href="../../d4/d86/group__imgproc__filter.html#ga27c049795ce870216ddfb366086b5a04" title="Convolves an image with the kernel.">cv.filter2D()</a></b> to convolve a kernel with an image. As an example, we will try an averaging filter on an image. A 5x5 averaging filter kernel will look like the below:</p>
<p class="formulaDsp">
\[K =  \frac{1}{25} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}\]
</p>
<p>The operation works like this: keep this kernel above a pixel, add all the 25 pixels below this kernel, take the average, and replace the central pixel with the new average value. This operation is continued for all the pixels in the image. Try this code and check the result: </p><div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</div>
<div class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</div>
<div class="line"> </div>
<div class="line">img = <a class="code hl_function" href="../../d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8">cv.imread</a>(<span class="stringliteral">&#39;opencv_logo.png&#39;</span>)</div>
<div class="line"><span class="keyword">assert</span> img <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>, <span class="stringliteral">&quot;file could not be read, check with os.path.exists()&quot;</span></div>
<div class="line"> </div>
<div class="line">kernel = np.ones((5,5),np.float32)/25</div>
<div class="line">dst = <a class="code hl_function" href="../../d4/d86/group__imgproc__filter.html#ga27c049795ce870216ddfb366086b5a04">cv.filter2D</a>(img,-1,kernel)</div>
<div class="line"> </div>
<div class="line">plt.subplot(121),plt.imshow(img),plt.title(<span class="stringliteral">&#39;Original&#39;</span>)</div>
<div class="line">plt.xticks([]), plt.yticks([])</div>
<div class="line">plt.subplot(122),plt.imshow(dst),plt.title(<span class="stringliteral">&#39;Averaging&#39;</span>)</div>
<div class="line">plt.xticks([]), plt.yticks([])</div>
<div class="line">plt.show()</div>
<div class="ttc" id="agroup__imgcodecs_html_gab32ee19e22660912565f8140d0f675a8"><div class="ttname"><a href="../../d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8">cv::imread</a></div><div class="ttdeci">CV_EXPORTS_W Mat imread(const String &amp;filename, int flags=IMREAD_COLOR)</div><div class="ttdoc">Loads an image from a file.</div></div>
<div class="ttc" id="agroup__imgproc__filter_html_ga27c049795ce870216ddfb366086b5a04"><div class="ttname"><a href="../../d4/d86/group__imgproc__filter.html#ga27c049795ce870216ddfb366086b5a04">cv::filter2D</a></div><div class="ttdeci">void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT)</div><div class="ttdoc">Convolves an image with the kernel.</div></div>
</div><!-- fragment --><p> Result:</p>
<div class="image">
<img src="../../filter.jpg" alt=""/>
<div class="caption">
image</div></div>
    <h1><a class="anchor" id="autotoc_md1362"></a>
Image Blurring (Image Smoothing)</h1>
<p>Image blurring is achieved by convolving the image with a low-pass filter kernel. It is useful for removing noise. It actually removes high frequency content (eg: noise, edges) from the image. So edges are blurred a little bit in this operation (there are also blurring techniques which don't blur the edges). OpenCV provides four main types of blurring techniques.</p>
<h2><a class="anchor" id="autotoc_md1363"></a>
1. Averaging</h2>
<p>This is done by convolving an image with a normalized box filter. It simply takes the average of all the pixels under the kernel area and replaces the central element. This is done by the function <b><a class="el" href="../../d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37" title="Blurs an image using the normalized box filter.">cv.blur()</a></b> or <b><a class="el" href="../../d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3" title="Blurs an image using the box filter.">cv.boxFilter()</a></b>. Check the docs for more details about the kernel. We should specify the width and height of the kernel. A 3x3 normalized box filter would look like the below:</p>
<p class="formulaDsp">
\[K =  \frac{1}{9} \begin{bmatrix} 1 &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}\]
</p>
<dl class="section note"><dt>Note</dt><dd>If you don't want to use a normalized box filter, use <b><a class="el" href="../../d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3" title="Blurs an image using the box filter.">cv.boxFilter()</a></b>. Pass an argument normalize=False to the function.</dd></dl>
<p>Check a sample demo below with a kernel of 5x5 size: </p><div class="fragment"><div class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</div>
<div class="line"> </div>
<div class="line">img = <a class="code hl_function" href="../../d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8">cv.imread</a>(<span class="stringliteral">&#39;opencv-logo-white.png&#39;</span>)</div>
<div class="line"><span class="keyword">assert</span> img <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>, <span class="stringliteral">&quot;file could not be read, check with os.path.exists()&quot;</span></div>
<div class="line"> </div>
<div class="line">blur = <a class="code hl_function" href="../../d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37">cv.blur</a>(img,(5,5))</div>
<div class="line"> </div>
<div class="line">plt.subplot(121),plt.imshow(img),plt.title(<span class="stringliteral">&#39;Original&#39;</span>)</div>
<div class="line">plt.xticks([]), plt.yticks([])</div>
<div class="line">plt.subplot(122),plt.imshow(blur),plt.title(<span class="stringliteral">&#39;Blurred&#39;</span>)</div>
<div class="line">plt.xticks([]), plt.yticks([])</div>
<div class="line">plt.show()</div>
<div class="ttc" id="agroup__imgproc__filter_html_ga8c45db9afe636703801b0b2e440fce37"><div class="ttname"><a href="../../d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37">cv::blur</a></div><div class="ttdeci">void blur(InputArray src, OutputArray dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT)</div><div class="ttdoc">Blurs an image using the normalized box filter.</div></div>
</div><!-- fragment --><p> Result:</p>
<div class="image">
<img src="../../blur.jpg" alt=""/>
<div class="caption">
image</div></div>
    <h2><a class="anchor" id="autotoc_md1364"></a>
2. Gaussian Blurring</h2>
<p>In this method, instead of a box filter, a Gaussian kernel is used. It is done with the function, <b><a class="el" href="../../d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1" title="Blurs an image using a Gaussian filter.">cv.GaussianBlur()</a></b>. We should specify the width and height of the kernel which should be positive and odd. We also should specify the standard deviation in the X and Y directions, sigmaX and sigmaY respectively. If only sigmaX is specified, sigmaY is taken as the same as sigmaX. If both are given as zeros, they are calculated from the kernel size. Gaussian blurring is highly effective in removing Gaussian noise from an image.</p>
<p>If you want, you can create a Gaussian kernel with the function, <b><a class="el" href="../../d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa" title="Returns Gaussian filter coefficients.">cv.getGaussianKernel()</a></b>.</p>
<p>The above code can be modified for Gaussian blurring: </p><div class="fragment"><div class="line">blur = <a class="code hl_function" href="../../d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1">cv.GaussianBlur</a>(img,(5,5),0)</div>
<div class="ttc" id="agroup__imgproc__filter_html_gaabe8c836e97159a9193fb0b11ac52cf1"><div class="ttname"><a href="../../d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1">cv::GaussianBlur</a></div><div class="ttdeci">void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT)</div><div class="ttdoc">Blurs an image using a Gaussian filter.</div></div>
</div><!-- fragment --><p> Result:</p>
<div class="image">
<img src="../../gaussian.jpg" alt=""/>
<div class="caption">
image</div></div>
    <h2><a class="anchor" id="autotoc_md1365"></a>
3. Median Blurring</h2>
<p>Here, the function <b><a class="el" href="../../d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9" title="Blurs an image using the median filter.">cv.medianBlur()</a></b> takes the median of all the pixels under the kernel area and the central element is replaced with this median value. This is highly effective against salt-and-pepper noise in an image. Interestingly, in the above filters, the central element is a newly calculated value which may be a pixel value in the image or a new value. But in median blurring, the central element is always replaced by some pixel value in the image. It reduces the noise effectively. Its kernel size should be a positive odd integer.</p>
<p>In this demo, I added a 50% noise to our original image and applied median blurring. Check the result: </p><div class="fragment"><div class="line">median = <a class="code hl_function" href="../../d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9">cv.medianBlur</a>(img,5)</div>
<div class="ttc" id="agroup__imgproc__filter_html_ga564869aa33e58769b4469101aac458f9"><div class="ttname"><a href="../../d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9">cv::medianBlur</a></div><div class="ttdeci">void medianBlur(InputArray src, OutputArray dst, int ksize)</div><div class="ttdoc">Blurs an image using the median filter.</div></div>
</div><!-- fragment --><p> Result:</p>
<div class="image">
<img src="../../median.jpg" alt=""/>
<div class="caption">
image</div></div>
    <h2><a class="anchor" id="autotoc_md1366"></a>
4. Bilateral Filtering</h2>
<p><b><a class="el" href="../../d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed" title="Applies the bilateral filter to an image.">cv.bilateralFilter()</a></b> is highly effective in noise removal while keeping edges sharp. But the operation is slower compared to other filters. We already saw that a Gaussian filter takes the neighbourhood around the pixel and finds its Gaussian weighted average. This Gaussian filter is a function of space alone, that is, nearby pixels are considered while filtering. It doesn't consider whether pixels have almost the same intensity. It doesn't consider whether a pixel is an edge pixel or not. So it blurs the edges also, which we don't want to do.</p>
<p>Bilateral filtering also takes a Gaussian filter in space, but one more Gaussian filter which is a function of pixel difference. The Gaussian function of space makes sure that only nearby pixels are considered for blurring, while the Gaussian function of intensity difference makes sure that only those pixels with similar intensities to the central pixel are considered for blurring. So it preserves the edges since pixels at edges will have large intensity variation.</p>
<p>The below sample shows use of a bilateral filter (For details on arguments, visit docs). </p><div class="fragment"><div class="line">blur = <a class="code hl_function" href="../../d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed">cv.bilateralFilter</a>(img,9,75,75)</div>
<div class="ttc" id="agroup__imgproc__filter_html_ga9d7064d478c95d60003cf839430737ed"><div class="ttname"><a href="../../d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed">cv::bilateralFilter</a></div><div class="ttdeci">void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType=BORDER_DEFAULT)</div><div class="ttdoc">Applies the bilateral filter to an image.</div></div>
</div><!-- fragment --><p> Result:</p>
<div class="image">
<img src="../../bilateral.jpg" alt=""/>
<div class="caption">
image</div></div>
    <p>See, the texture on the surface is gone, but the edges are still preserved.</p>
<h1><a class="anchor" id="autotoc_md1367"></a>
Additional Resources</h1>
<ol type="1">
<li>Details about the <a href="http://people.csail.mit.edu/sparis/bf_course/" target="_blank">bilateral filtering</a></li>
</ol>
<h1><a class="anchor" id="autotoc_md1368"></a>
Exercises</h1>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 2 2024 21:52:14 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.9.8
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
