<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>OpenCV: Adding a new algorithm to the Facemark API</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
//<![CDATA[
window.MathJax = {
    loader: {load: ['[tex]/ams']},
    tex: {
        packages: {'[+]': ['ams']},
        macros: {
            matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
            fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
            forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
            forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
            vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
            vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
            cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
            distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
            distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
            hdotsfor: ["\\dots", 1],
            mathbbm: ["\\mathbb{#1}", 1],
            bordermatrix: ["\\matrix{#1}", 1]
        },
        processEscapes: false
    }
};
//]]>
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.10.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d3/d81/tutorial_contrib_root.html">Tutorials for contrib modules</a></li><li class="navelem"><a class="el" href="../../d5/d47/tutorial_table_of_content_facemark.html">Tutorial on Facial Landmark Detector API</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Adding a new algorithm to the Facemark API</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1926"></a>
Goals</h1>
<p>In this tutorial you will learn how to:</p><ul>
<li>integrate a new algorithm of facial landmark detector into the Facemark API</li>
<li>compile a specific contrib module</li>
<li>using extra parameters in a function</li>
</ul>
<h1><a class="anchor" id="autotoc_md1927"></a>
Explanation</h1>
<ul>
<li><p class="startli"><b>Add the class header</b></p>
<p class="startli">The class header for a new algorithm should be added to a new file in include/opencv2/face. Here is the template that you can use to integrate a new algorithm, change the FacemarkNEW to a representative name of the new algorithm and save it using a representative filename accordingly. </p><pre class="fragment">@code{.cpp}
class CV_EXPORTS_W FacemarkNEW : public Facemark {
public:
    struct CV_EXPORTS Config {
        Config();

        /*read only parameters - just for example*/
        double detect_thresh;         //!&lt;  detection confidence threshold
        double sigma;                 //!&lt;  another parameter

        void read(const FileNode&amp; /*fn*/);
        void write(FileStorage&amp; /*fs*/) const;
    };

    /*Builder and destructor*/
    static Ptr&lt;FacemarkNEW&gt; create(const FacemarkNEW::Config &amp;conf = FacemarkNEW::Config() );
    virtual ~FacemarkNEW(){};
};
@endcode
</pre></li>
<li><p class="startli"><b>Add the implementation code</b></p>
<p class="startli">Create a new file in the source folder with name representing the new algorithm. Here is the template that you can use. </p><pre class="fragment">@code{.cpp}
#include "opencv2/face.hpp"
#include "precomp.hpp"

namespace cv
{
    FacemarkNEW::Config::Config(){
        detect_thresh = 0.5;
        sigma=0.2;
    }

    void FacemarkNEW::Config::read( const cv::FileNode&amp; fn ){
        *this = FacemarkNEW::Config();

        if (!fn["detect_thresh"].empty())
            fn["detect_thresh"] &gt;&gt; detect_thresh;

        if (!fn["sigma"].empty())
            fn["sigma"] &gt;&gt; sigma;

    }

    void FacemarkNEW::Config::write( cv::FileStorage&amp; fs ) const{
        fs &lt;&lt; "detect_thresh" &lt;&lt; detect_thresh;
        fs &lt;&lt; "sigma" &lt;&lt; sigma;
    }

    /*implementation of the algorithm is in this class*/
    class FacemarkNEWImpl : public FacemarkNEW {
    public:
        FacemarkNEWImpl( const FacemarkNEW::Config &amp;conf = FacemarkNEW::Config() );

        void read( const FileNode&amp; /*fn*/ );
        void write( FileStorage&amp; /*fs*/ ) const;

        void loadModel(String filename);

        bool setFaceDetector(bool(*f)(InputArray , OutputArray, void * extra_params));
        bool getFaces( InputArray image , OutputArray faces, void * extra_params);

        Config config;

    protected:

        bool addTrainingSample(InputArray image, InputArray landmarks);
        void training();
        bool fit(InputArray image, InputArray faces, InputOutputArray landmarks, void * runtime_params);

        Config config; // configurations

        /*proxy to the user defined face detector function*/
        bool(*faceDetector)(InputArray , OutputArray, void * );
    }; // class

    Ptr&lt;FacemarkNEW&gt; FacemarkNEW::create(const FacemarkNEW::Config &amp;conf){
        return Ptr&lt;FacemarkNEWImpl&gt;(new FacemarkNEWImpl(conf));
    }

    FacemarkNEWImpl::FacemarkNEWImpl( const FacemarkNEW::Config &amp;conf ) :
        config( conf )
    {
        // other initialization
    }

    bool FacemarkNEWImpl::addTrainingSample(InputArray image, InputArray landmarks){
        // pre-process and save the new training sample
        return true;
    }

    void FacemarkNEWImpl::training(){
        printf("training\n");
    }

    bool FacemarkNEWImpl::fit(
        InputArray image,
        InputArray faces,
        InputOutputArray landmarks,
        void * runtime_params)
    {
        if(runtime_params!=0){
            // do something based on the extra parameters
        }

        printf("fitting\n");
        return 0;
    }

    void FacemarkNEWImpl::read( const cv::FileNode&amp; fn ){
        config.read( fn );
    }

    void FacemarkNEWImpl::write( cv::FileStorage&amp; fs ) const {
        config.write( fs );
    }

    void FacemarkNEWImpl::loadModel(String filename){
        // load the model
    }

    bool FacemarkNEWImpl::setFaceDetector(bool(*f)(InputArray , OutputArray, void * extra_params )){
        faceDetector = f;
        isSetDetector = true;
        return true;
    }

    bool FacemarkNEWImpl::getFaces( InputArray image , OutputArray roi, void * extra_params){
        if(!isSetDetector){
            return false;
        }

        if(extra_params!=0){
            //extract the extra parameters
        }

        std::vector&lt;Rect&gt; &amp; faces = *(std::vector&lt;Rect&gt;*)roi.getObj();
        faces.clear();

        faceDetector(image.getMat(), faces, extra_params);

        return true;
    }
}

@endcode
</pre></li>
<li><p class="startli"><b>Compiling the code</b></p>
<p class="startli">Clear the build folder and then rebuild the entire library. Note that you can deactivate the compilation of other contrib modules by adding "-D BUILD_opencv_&lt;MODULE_NAME&gt;=OFF" flag to the cmake. After that you can execute make command in "&lt;build_folder&gt;/modules/face" to speed up the compiling process.</p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1928"></a>
Best Practice</h1>
<ul>
<li><p class="startli"><b>Handling the extra parameters</b> To handle the extra parameters, a new struct should be created to holds all the required parameters. Here is an example of of a parameters container </p><div class="fragment"><div class="line">struct CV_EXPORTS Params</div>
<div class="line">{</div>
<div class="line">    Params( Mat rot = Mat::eye(2,2,CV_32F),</div>
<div class="line">            Point2f trans = Point2f(0.0,0.0),</div>
<div class="line">            float scaling = 1.0</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    Mat R;</div>
<div class="line">    Point2f t;</div>
<div class="line">    float scale;</div>
<div class="line">};</div>
</div><!-- fragment --><p class="startli">Here is a snippet to extract the extra parameters: </p><div class="fragment"><div class="line">if(runtime_params!=0){</div>
<div class="line">    Telo*  conf = (Telo*)params;</div>
<div class="line">    Params* params</div>
<div class="line">    std::vector&lt;Params&gt; params = *(std::vector&lt;Params&gt;*)runtime_params;</div>
<div class="line">    for(size_t i=0; i&lt;params.size();i++){</div>
<div class="line">        fit(img, landmarks[i], params[i].R,params[i].t, params[i].scale);</div>
<div class="line">    }</div>
<div class="line">}else{</div>
<div class="line">    // do something</div>
<div class="line">}</div>
</div><!-- fragment --><p class="startli">And here is an example to pass the extra parameter into fit function </p><div class="fragment"><div class="line">FacemarkAAM::Params * params = new FacemarkAAM::Params(R,T,scale);</div>
<div class="line">facemark-&gt;fit(image, faces, landmarks, params)</div>
</div><!-- fragment --><p class="startli">In order to understand this scheme, here is a simple example that you can try to compile and see how it works. </p><div class="fragment"><div class="line">struct Params{</div>
<div class="line">    int x,y;</div>
<div class="line">    Params(int _x, int _y);</div>
<div class="line">};</div>
<div class="line">Params::Params(int _x,int _y){</div>
<div class="line">    x = _x;</div>
<div class="line">    y = _y;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void test(int a, void * params=0){</div>
<div class="line">    printf(&quot;a:%i\n&quot;, a);</div>
<div class="line">    if(params!=0){</div>
<div class="line">        Params*  params = (Params*)params;</div>
<div class="line">        printf(&quot;extra parameters:%i %i\n&quot;, params-&gt;x, params-&gt;y);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main(){</div>
<div class="line">    Params* params = new Params(7,22);</div>
<div class="line">    test(99, params);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>Minimize the dependency</b> It is highly recomended to keep the code as small as possible when compiled. For this purpose, the developers are ecouraged to avoid the needs of heavy dependency such as <code>imgcodecs</code> and <code>highgui</code>.</li>
<li><b>Documentation and examples</b> Please update the documentation whenever needed and put example code for the new algorithm.</li>
<li><b>Test codes</b> An algorithm should be accompanied with its corresponding test code to ensure that the algorithm is compatible with various types of environment (Linux, Windows64, Windows32, Android, etc). There are several basic test that should be performed as demonstrated in the test/test_facemark_lbf.cpp file including cration of its instance, add training data, perform the training process, load a trained model, and perform the fitting to obtain facial landmarks.</li>
<li><b>Data organization</b> It is advised to divide the data for a new algorithm into 3 parts : <div class="fragment"><div class="line">class CV_EXPORTS_W FacemarkNEW : public Facemark {</div>
<div class="line">public:</div>
<div class="line">    struct CV_EXPORTS Params</div>
<div class="line">    {</div>
<div class="line">        // variables utilized as extra parameters</div>
<div class="line">    }</div>
<div class="line">    struct CV_EXPORTS Config</div>
<div class="line">    {</div>
<div class="line">        // variables used to configure the algorithm</div>
<div class="line">    }</div>
<div class="line">    struct CV_EXPORTS Model</div>
<div class="line">    {</div>
<div class="line">        // variables to store the information of model</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    static Ptr&lt;FacemarkNEW&gt; create(const FacemarkNEW::Config &amp;conf = FacemarkNEW::Config() );</div>
<div class="line">    virtual ~FacemarkNEW(){};</div>
<div class="line">}</div>
</div><!-- fragment --> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 2 2024 21:52:14 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.9.8
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
