<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>OpenCV: Conversion of TensorFlow Segmentation Models and Launch with OpenCV</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
//<![CDATA[
window.MathJax = {
    loader: {load: ['[tex]/ams']},
    tex: {
        packages: {'[+]': ['ams']},
        macros: {
            matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
            fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
            forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
            forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
            vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
            vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
            cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
            distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
            distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
            hdotsfor: ["\\dots", 1],
            mathbbm: ["\\mathbb{#1}", 1],
            bordermatrix: ["\\matrix{#1}", 1]
        },
        processEscapes: false
    }
};
//]]>
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.10.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/df8/tutorial_root.html">OpenCV Tutorials</a></li><li class="navelem"><a class="el" href="../../d2/d58/tutorial_table_of_content_dnn.html">Deep Neural Networks (dnn module)</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Conversion of TensorFlow Segmentation Models and Launch with OpenCV</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md419"></a>
Goals</h1>
<p>In this tutorial you will learn how to:</p><ul>
<li>convert TensorFlow (TF) segmentation models</li>
<li>run converted TensorFlow model with OpenCV</li>
<li>obtain an evaluation of the TensorFlow and OpenCV DNN models</li>
</ul>
<p>We will explore the above-listed points by the example of the DeepLab architecture.</p>
<h1><a class="anchor" id="autotoc_md420"></a>
Introduction</h1>
<p>The key concepts involved in the transition pipeline of the <a href="https://link_to_cls_tutorial" target="_blank">TensorFlow classification</a> and segmentation models with OpenCV API are almost equal excepting the phase of graph optimization. The initial step in conversion of TensorFlow models into <a class="el" href="../../db/d30/classcv_1_1dnn_1_1Net.html" title="This class allows to create and manipulate comprehensive artificial neural networks.">cv.dnn.Net</a> is obtaining the frozen TF model graph. Frozen graph defines the combination of the model graph structure with kept values of the required variables, for example, weights. Usually the frozen graph is saved in <a href="https://en.wikipedia.org/wiki/Protocol_Buffers" target="_blank">protobuf</a> (<code>.pb</code>) files. To read the generated segmentation model <code>.pb</code> file with <a class="el" href="../../d6/d0f/group__dnn.html#ga91c313cd8269ddddaf3cb8299df2d4cb" title="Reads a network model stored in TensorFlow framework&#39;s format.">cv.dnn.readNetFromTensorflow</a>, it is needed to modify the graph with TF <a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/tools/graph_transforms" target="_blank">graph transform tool</a>.</p>
<h1><a class="anchor" id="autotoc_md421"></a>
Practice</h1>
<p>In this part we are going to cover the following points:</p><ol type="1">
<li>create a TF classification model conversion pipeline and provide the inference</li>
<li>evaluate and test TF classification models</li>
</ol>
<p>If you'd like merely to run evaluation or test model pipelines, the "Model Conversion Pipeline" tutorial part can be skipped.</p>
<h2><a class="anchor" id="autotoc_md422"></a>
Model Conversion Pipeline</h2>
<p>The code in this subchapter is located in the <code>dnn_model_runner</code> module and can be executed with the line:</p>
<div class="fragment"><div class="line">python -m dnn_model_runner.dnn_conversion.tf.segmentation.py_to_py_deeplab</div>
</div><!-- fragment --><p>TensorFlow segmentation models can be found in <a href="https://github.com/tensorflow/models/tree/master/research/#tensorflow-research-models" target="_blank">TensorFlow Research Models</a> section, which contains the implementations of models on the basis of published research papers. We will retrieve the archive with the pre-trained TF DeepLabV3 from the below link:</p>
<div class="fragment"><div class="line">http://download.tensorflow.org/models/deeplabv3_mnv2_pascal_trainval_2018_01_29.tar.gz</div>
</div><!-- fragment --><p>The full frozen graph obtaining pipeline is described in <code>deeplab_retrievement.py</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>get_deeplab_frozen_graph():</div>
<div class="line">    <span class="comment"># define model path to download</span></div>
<div class="line">    models_url = <span class="stringliteral">&#39;http://download.tensorflow.org/models/&#39;</span></div>
<div class="line">    mobilenetv2_voctrainval = <span class="stringliteral">&#39;deeplabv3_mnv2_pascal_trainval_2018_01_29.tar.gz&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># construct model link to download</span></div>
<div class="line">    model_link = models_url + mobilenetv2_voctrainval</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        urllib.request.urlretrieve(model_link, mobilenetv2_voctrainval)</div>
<div class="line">    <span class="keywordflow">except</span> Exception:</div>
<div class="line">        print(<span class="stringliteral">&quot;TF DeepLabV3 was not retrieved: {}&quot;</span>.format(model_link))</div>
<div class="line">        <span class="keywordflow">return</span></div>
<div class="line"> </div>
<div class="line">    tf_model_tar = tarfile.open(mobilenetv2_voctrainval)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># iterate the obtained model archive</span></div>
<div class="line">    <span class="keywordflow">for</span> model_tar_elem <span class="keywordflow">in</span> tf_model_tar.getmembers():</div>
<div class="line">        <span class="comment"># check whether the model archive contains frozen graph</span></div>
<div class="line">        <span class="keywordflow">if</span> TF_FROZEN_GRAPH_NAME <span class="keywordflow">in</span> os.path.basename(model_tar_elem.name):</div>
<div class="line">            <span class="comment"># extract frozen graph</span></div>
<div class="line">            tf_model_tar.extract(model_tar_elem, FROZEN_GRAPH_PATH)</div>
<div class="line"> </div>
<div class="line">    tf_model_tar.close()</div>
</div><!-- fragment --><p>After running this script:</p>
<div class="fragment"><div class="line">python -m dnn_model_runner.dnn_conversion.tf.segmentation.deeplab_retrievement</div>
</div><!-- fragment --><p>we will get <code>frozen_inference_graph.pb</code> in <code>deeplab/deeplabv3_mnv2_pascal_trainval</code>.</p>
<p>Before going to the network loading with OpenCV it is needed to optimize the extracted <code>frozen_inference_graph.pb</code>. To optimize the graph we use TF <code>TransformGraph</code> with default parameters:</p>
<div class="fragment"><div class="line">DEFAULT_OPT_GRAPH_NAME = <span class="stringliteral">&quot;optimized_frozen_inference_graph.pb&quot;</span></div>
<div class="line">DEFAULT_INPUTS = <span class="stringliteral">&quot;sub_7&quot;</span></div>
<div class="line">DEFAULT_OUTPUTS = <span class="stringliteral">&quot;ResizeBilinear_3&quot;</span></div>
<div class="line">DEFAULT_TRANSFORMS = <span class="stringliteral">&quot;remove_nodes(op=Identity)&quot;</span> \</div>
<div class="line">                     <span class="stringliteral">&quot; merge_duplicate_nodes&quot;</span> \</div>
<div class="line">                     <span class="stringliteral">&quot; strip_unused_nodes&quot;</span> \</div>
<div class="line">                     <span class="stringliteral">&quot; fold_constants(ignore_errors=true)&quot;</span> \</div>
<div class="line">                     <span class="stringliteral">&quot; fold_batch_norms&quot;</span> \</div>
<div class="line">                     <span class="stringliteral">&quot; fold_old_batch_norms&quot;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>optimize_tf_graph(</div>
<div class="line">        in_graph,</div>
<div class="line">        out_graph=DEFAULT_OPT_GRAPH_NAME,</div>
<div class="line">        inputs=DEFAULT_INPUTS,</div>
<div class="line">        outputs=DEFAULT_OUTPUTS,</div>
<div class="line">        transforms=DEFAULT_TRANSFORMS,</div>
<div class="line">        is_manual=True,</div>
<div class="line">        was_optimized=True</div>
<div class="line">):</div>
<div class="line">    <span class="comment"># ...</span></div>
<div class="line"> </div>
<div class="line">    tf_opt_graph = TransformGraph(</div>
<div class="line">        tf_graph,</div>
<div class="line">        inputs,</div>
<div class="line">        outputs,</div>
<div class="line">        transforms</div>
<div class="line">    )</div>
</div><!-- fragment --><p>To run graph optimization process, execute the line:</p>
<div class="fragment"><div class="line">python -m dnn_model_runner.dnn_conversion.tf.segmentation.tf_graph_optimizer --in_graph deeplab/deeplabv3_mnv2_pascal_trainval/frozen_inference_graph.pb</div>
</div><!-- fragment --><p>As a result <code>deeplab/deeplabv3_mnv2_pascal_trainval</code> directory will contain <code>optimized_frozen_inference_graph.pb</code>.</p>
<p>After we have obtained the model graphs, let's examine the below-listed steps:</p><ol type="1">
<li>read TF <code>frozen_inference_graph.pb</code> graph</li>
<li>read optimized TF frozen graph with OpenCV API</li>
<li>prepare input data</li>
<li>provide inference</li>
<li>get colored masks from predictions</li>
<li>visualize results</li>
</ol>
<div class="fragment"><div class="line"><span class="comment"># get TF model graph from the obtained frozen graph</span></div>
<div class="line">deeplab_graph = read_deeplab_frozen_graph(deeplab_frozen_graph_path)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># read DeepLab frozen graph with OpenCV API</span></div>
<div class="line">opencv_net = cv2.dnn.readNetFromTensorflow(opt_deeplab_frozen_graph_path)</div>
<div class="line">print(<span class="stringliteral">&quot;OpenCV model was successfully read. Model layers: \n&quot;</span>, opencv_net.getLayerNames())</div>
<div class="line"> </div>
<div class="line"><span class="comment"># get processed image</span></div>
<div class="line">original_img_shape, tf_input_blob, opencv_input_img = get_processed_imgs(<span class="stringliteral">&quot;test_data/sem_segm/2007_000033.jpg&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># obtain OpenCV DNN predictions</span></div>
<div class="line">opencv_prediction = get_opencv_dnn_prediction(opencv_net, opencv_input_img)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># obtain TF model predictions</span></div>
<div class="line">tf_prediction = get_tf_dnn_prediction(deeplab_graph, tf_input_blob)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># get PASCAL VOC classes and colors</span></div>
<div class="line">pascal_voc_classes, pascal_voc_colors = read_colors_info(<span class="stringliteral">&quot;test_data/sem_segm/pascal-classes.txt&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># obtain colored segmentation masks</span></div>
<div class="line">opencv_colored_mask = get_colored_mask(original_img_shape, opencv_prediction, pascal_voc_colors)</div>
<div class="line">tf_colored_mask = get_tf_colored_mask(original_img_shape, tf_prediction, pascal_voc_colors)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># obtain palette of PASCAL VOC colors</span></div>
<div class="line">color_legend = get_legend(pascal_voc_classes, pascal_voc_colors)</div>
<div class="line"> </div>
<div class="line">cv2.imshow(<span class="stringliteral">&#39;TensorFlow Colored Mask&#39;</span>, tf_colored_mask)</div>
<div class="line">cv2.imshow(<span class="stringliteral">&#39;OpenCV DNN Colored Mask&#39;</span>, opencv_colored_mask)</div>
<div class="line"> </div>
<div class="line">cv2.imshow(<span class="stringliteral">&#39;Color Legend&#39;</span>, color_legend)</div>
</div><!-- fragment --><p>To provide the model inference we will use the below picture from the <a href="http://host.robots.ox.ac.uk/pascal/VOC/" target="_blank">PASCAL VOC</a> validation dataset:</p>
<p><img src="../../images/2007_000033.jpg" alt="PASCAL VOC img" class="inline"/></p>
<p>The target segmented result is:</p>
<p><img src="../../images/2007_000033.png" alt="PASCAL VOC ground truth" class="inline"/></p>
<p>For the PASCAL VOC colors decoding and its mapping with the predicted masks, we also need <code>pascal-classes.txt</code> file, which contains the full list of the PASCAL VOC classes and corresponding colors.</p>
<p>Let's go deeper into each step by the example of pretrained TF DeepLabV3 MobileNetV2:</p>
<ul>
<li>read TF <code>frozen_inference_graph.pb</code> graph :</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># init deeplab model graph</span></div>
<div class="line">model_graph = tf.Graph()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># obtain</span></div>
<div class="line"><span class="keyword">with</span> tf.io.gfile.GFile(frozen_graph_path, <span class="stringliteral">&#39;rb&#39;</span>) <span class="keyword">as</span> graph_file:</div>
<div class="line">    tf_model_graph = GraphDef()</div>
<div class="line">tf_model_graph.ParseFromString(graph_file.read())</div>
<div class="line"> </div>
<div class="line"><span class="keyword">with</span> model_graph.as_default():</div>
<div class="line">    tf.import_graph_def(tf_model_graph, name=<span class="stringliteral">&#39;&#39;</span>)</div>
</div><!-- fragment --><ul>
<li>read optimized TF frozen graph with OpenCV API:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># read DeepLab frozen graph with OpenCV API</span></div>
<div class="line">opencv_net = cv2.dnn.readNetFromTensorflow(opt_deeplab_frozen_graph_path)</div>
</div><!-- fragment --><ul>
<li>prepare input data with cv2.dnn.blobFromImage function:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># read the image</span></div>
<div class="line">input_img = cv2.imread(img_path, cv2.IMREAD_COLOR)</div>
<div class="line">input_img = input_img.astype(np.float32)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># preprocess image for TF model input</span></div>
<div class="line">tf_preproc_img = cv2.resize(input_img, (513, 513))</div>
<div class="line">tf_preproc_img = cv2.cvtColor(tf_preproc_img, cv2.COLOR_BGR2RGB)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># define preprocess parameters for OpenCV DNN</span></div>
<div class="line">mean = np.array([1.0, 1.0, 1.0]) * 127.5</div>
<div class="line">scale = 1 / 127.5</div>
<div class="line"> </div>
<div class="line"><span class="comment"># prepare input blob to fit the model input:</span></div>
<div class="line"><span class="comment"># 1. subtract mean</span></div>
<div class="line"><span class="comment"># 2. scale to set pixel values from 0 to 1</span></div>
<div class="line">input_blob = cv2.dnn.blobFromImage(</div>
<div class="line">    image=input_img,</div>
<div class="line">    scalefactor=scale,</div>
<div class="line">    size=(513, 513),  <span class="comment"># img target size</span></div>
<div class="line">    mean=mean,</div>
<div class="line">    swapRB=<span class="keyword">True</span>,  <span class="comment"># BGR -&gt; RGB</span></div>
<div class="line">    crop=<span class="keyword">False</span>  <span class="comment"># center crop</span></div>
<div class="line">)</div>
</div><!-- fragment --><p>Please, pay attention at the preprocessing order in the <code>cv2.dnn.blobFromImage</code> function. Firstly, the mean value is subtracted and only then pixel values are multiplied by the defined scale. Therefore, to reproduce TF image preprocessing pipeline, we multiply <code>mean</code> by <code>127.5</code>. Another important point is image preprocessing for TF DeepLab. To pass the image into TF model we need only to construct an appropriate shape, the rest image preprocessing is described in <a href="https://github.com/tensorflow/models/blob/master/research/deeplab/core/feature_extractor.py" target="_blank">feature_extractor.py</a> and will be invoked automatically.</p>
<ul>
<li>provide OpenCV <code>cv.dnn_Net</code> inference:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># set OpenCV DNN input</span></div>
<div class="line">opencv_net.setInput(preproc_img)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># OpenCV DNN inference</span></div>
<div class="line">out = opencv_net.forward()</div>
<div class="line">print(<span class="stringliteral">&quot;OpenCV DNN segmentation prediction: \n&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;* shape: &quot;</span>, out.shape)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># get IDs of predicted classes</span></div>
<div class="line">out_predictions = np.argmax(out[0], axis=0)</div>
</div><!-- fragment --><p>After the above code execution we will get the following output:</p>
<div class="fragment"><div class="line">OpenCV DNN segmentation prediction:</div>
<div class="line">* shape:  (1, 21, 513, 513)</div>
</div><!-- fragment --><p>Each prediction channel out of 21, where 21 represents the number of PASCAL VOC classes, contains probabilities, which indicate how likely the pixel corresponds to the PASCAL VOC class.</p>
<ul>
<li>provide TF model inference:</li>
</ul>
<div class="fragment"><div class="line">preproc_img = np.expand_dims(preproc_img, 0)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># init TF session</span></div>
<div class="line">tf_session = Session(graph=model_graph)</div>
<div class="line"> </div>
<div class="line">input_tensor_name = <span class="stringliteral">&quot;ImageTensor:0&quot;</span>,</div>
<div class="line">output_tensor_name = <span class="stringliteral">&quot;SemanticPredictions:0&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># run inference</span></div>
<div class="line">out = tf_session.run(</div>
<div class="line">    output_tensor_name,</div>
<div class="line">    feed_dict={input_tensor_name: [preproc_img]}</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;TF segmentation model prediction: \n&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;* shape: &quot;</span>, out.shape)</div>
</div><!-- fragment --><p>TF inference results are the following:</p>
<div class="fragment"><div class="line">TF segmentation model prediction:</div>
<div class="line">* shape:  (1, 513, 513)</div>
</div><!-- fragment --><p>TensorFlow prediction contains the indexes of corresponding PASCAL VOC classes.</p>
<ul>
<li>transform OpenCV prediction into colored mask:</li>
</ul>
<div class="fragment"><div class="line">mask_height = segm_mask.shape[0]</div>
<div class="line">mask_width = segm_mask.shape[1]</div>
<div class="line"> </div>
<div class="line">img_height = original_img_shape[0]</div>
<div class="line">img_width = original_img_shape[1]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># convert mask values into PASCAL VOC colors</span></div>
<div class="line">processed_mask = np.stack([colors[color_id] <span class="keywordflow">for</span> color_id <span class="keywordflow">in</span> segm_mask.flatten()])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># reshape mask into 3-channel image</span></div>
<div class="line">processed_mask = processed_mask.reshape(mask_height, mask_width, 3)</div>
<div class="line">processed_mask = cv2.resize(processed_mask, (img_width, img_height), interpolation=cv2.INTER_NEAREST).astype(</div>
<div class="line">    np.uint8)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># convert colored mask from BGR to RGB</span></div>
<div class="line">processed_mask = cv2.cvtColor(processed_mask, cv2.COLOR_BGR2RGB)</div>
</div><!-- fragment --><p>In this step we map the probabilities from segmentation masks with appropriate colors of the predicted classes. Let's have a look at the results:</p>
<p><img src="../../images/colors_legend.png" alt="Color Legend" class="inline"/></p>
<p><img src="../../images/deeplab_opencv_colored_mask.png" alt="OpenCV Colored Mask" class="inline"/></p>
<ul>
<li>transform TF prediction into colored mask:</li>
</ul>
<div class="fragment"><div class="line">colors = np.array(colors)</div>
<div class="line">processed_mask = colors[segm_mask[0]]</div>
<div class="line"> </div>
<div class="line">img_height = original_img_shape[0]</div>
<div class="line">img_width = original_img_shape[1]</div>
<div class="line"> </div>
<div class="line">processed_mask = cv2.resize(processed_mask, (img_width, img_height), interpolation=cv2.INTER_NEAREST).astype(</div>
<div class="line">    np.uint8)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># convert colored mask from BGR to RGB for compatibility with PASCAL VOC colors</span></div>
<div class="line">processed_mask = cv2.cvtColor(processed_mask, cv2.COLOR_BGR2RGB)</div>
</div><!-- fragment --><p>The result is:</p>
<p><img src="../../images/deeplab_tf_colored_mask.png" alt="TF Colored Mask" class="inline"/></p>
<p>As a result, we get two equal segmentation masks.</p>
<h2><a class="anchor" id="autotoc_md423"></a>
Evaluation of the Models</h2>
<p>The proposed in <code>dnn/samples</code> <code>dnn_model_runner</code> module allows to run the full evaluation pipeline on the PASCAL VOC dataset and test execution for the DeepLab MobileNet model.</p>
<h3><a class="anchor" id="autotoc_md424"></a>
Evaluation Mode</h3>
<p>To below line represents running of the module in the evaluation mode:</p>
<div class="fragment"><div class="line">python -m dnn_model_runner.dnn_conversion.tf.segmentation.py_to_py_segm</div>
</div><!-- fragment --><p>The model will be read into OpenCV <code>cv.dnn_Net</code> object. Evaluation results of TF and OpenCV models (pixel accuracy, mean IoU, inference time) will be written into the log file. Inference time values will be also depicted in a chart to generalize the obtained model information.</p>
<p>Necessary evaluation configurations are defined in the <a href="https://github.com/opencv/opencv/tree/4.x/samples/dnn/dnn_model_runner/dnn_conversion/common/test/configs/test_config.py" target="_blank"><code>test_config.py</code></a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">@dataclass</span></div>
<div class="line"><span class="keyword">class </span>TestSegmConfig:</div>
<div class="line">    frame_size: int = 500</div>
<div class="line">    img_root_dir: str = <span class="stringliteral">&quot;./VOC2012&quot;</span></div>
<div class="line">    img_dir: str = os.path.join(img_root_dir, <span class="stringliteral">&quot;JPEGImages/&quot;</span>)</div>
<div class="line">    img_segm_gt_dir: str = os.path.join(img_root_dir, <span class="stringliteral">&quot;SegmentationClass/&quot;</span>)</div>
<div class="line">    <span class="comment"># reduced val: https://github.com/shelhamer/fcn.berkeleyvision.org/blob/master/data/pascal/seg11valid.txt</span></div>
<div class="line">    segm_val_file: str = os.path.join(img_root_dir, <span class="stringliteral">&quot;ImageSets/Segmentation/seg11valid.txt&quot;</span>)</div>
<div class="line">    colour_file_cls: str = os.path.join(img_root_dir, <span class="stringliteral">&quot;ImageSets/Segmentation/pascal-classes.txt&quot;</span>)</div>
</div><!-- fragment --><p>These values can be modified in accordance with chosen model pipeline.</p>
<h3><a class="anchor" id="autotoc_md425"></a>
Test Mode</h3>
<p>The below line represents running of the module in the test mode, which provides the steps for the model inference:</p>
<div class="fragment"><div class="line">python -m dnn_model_runner.dnn_conversion.tf.segmentation.py_to_py_segm --test True --default_img_preprocess &lt;True/False&gt; --evaluate False</div>
</div><!-- fragment --><p>Here <code>default_img_preprocess</code> key defines whether you'd like to parametrize the model test process with some particular values or use the default values, for example, <code>scale</code>, <code>mean</code> or <code>std</code>.</p>
<p>Test configuration is represented in <a href="https://github.com/opencv/opencv/tree/4.x/samples/dnn/dnn_model_runner/dnn_conversion/common/test/configs/test_config.py" target="_blank"><code>test_config.py</code></a> <code>TestSegmModuleConfig</code> class:</p>
<div class="fragment"><div class="line"><span class="preprocessor">@dataclass</span></div>
<div class="line"><span class="keyword">class </span>TestSegmModuleConfig:</div>
<div class="line">    segm_test_data_dir: str = <span class="stringliteral">&quot;test_data/sem_segm&quot;</span></div>
<div class="line">    test_module_name: str = <span class="stringliteral">&quot;segmentation&quot;</span></div>
<div class="line">    test_module_path: str = <span class="stringliteral">&quot;segmentation.py&quot;</span></div>
<div class="line">    input_img: str = os.path.join(segm_test_data_dir, <span class="stringliteral">&quot;2007_000033.jpg&quot;</span>)</div>
<div class="line">    model: str = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    frame_height: str = str(TestSegmConfig.frame_size)</div>
<div class="line">    frame_width: str = str(TestSegmConfig.frame_size)</div>
<div class="line">    scale: float = 1.0</div>
<div class="line">    mean: List[float] = field(default_factory=<span class="keyword">lambda</span>: [0.0, 0.0, 0.0])</div>
<div class="line">    std: List[float] = field(default_factory=list)</div>
<div class="line">    crop: bool = <span class="keyword">False</span></div>
<div class="line">    rgb: bool = <span class="keyword">True</span></div>
<div class="line">    classes: str = os.path.join(segm_test_data_dir, <span class="stringliteral">&quot;pascal-classes.txt&quot;</span>)</div>
</div><!-- fragment --><p>The default image preprocessing options are defined in <code>default_preprocess_config.py</code>:</p>
<div class="fragment"><div class="line">tf_segm_input_blob = {</div>
<div class="line">    <span class="stringliteral">&quot;scale&quot;</span>: str(1 / 127.5),</div>
<div class="line">    <span class="stringliteral">&quot;mean&quot;</span>: [<span class="stringliteral">&quot;127.5&quot;</span>, <span class="stringliteral">&quot;127.5&quot;</span>, <span class="stringliteral">&quot;127.5&quot;</span>],</div>
<div class="line">    <span class="stringliteral">&quot;std&quot;</span>: [],</div>
<div class="line">    <span class="stringliteral">&quot;crop&quot;</span>: <span class="stringliteral">&quot;False&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;rgb&quot;</span>: <span class="stringliteral">&quot;True&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The basis of the model testing is represented in <code>samples/dnn/segmentation.py</code>. <code>segmentation.py</code> can be executed autonomously with provided converted model in <code>--input</code> and populated parameters for <code>cv2.dnn.blobFromImage</code>.</p>
<p>To reproduce from scratch the described in "Model Conversion Pipeline" OpenCV steps with <code>dnn_model_runner</code> execute the below line:</p>
<div class="fragment"><div class="line">python -m dnn_model_runner.dnn_conversion.tf.segmentation.py_to_py_segm --test True --default_img_preprocess True --evaluate False</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 2 2024 21:52:13 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.9.8
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
