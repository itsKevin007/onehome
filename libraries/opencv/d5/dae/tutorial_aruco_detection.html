<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>OpenCV: Detection of ArUco Markers</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
//<![CDATA[
window.MathJax = {
    loader: {load: ['[tex]/ams']},
    tex: {
        packages: {'[+]': ['ams']},
        macros: {
            matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
            fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
            forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
            forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
            vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
            vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
            cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
            distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
            distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
            hdotsfor: ["\\dots", 1],
            mathbbm: ["\\mathbb{#1}", 1],
            bordermatrix: ["\\matrix{#1}", 1]
        },
        processEscapes: false
    }
};
//]]>
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.10.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/df8/tutorial_root.html">OpenCV Tutorials</a></li><li class="navelem"><a class="el" href="../../d2/d64/tutorial_table_of_content_objdetect.html">Object Detection (objdetect module)</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Detection of ArUco Markers</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Next Tutorial:</b> <a class="el" href="../../db/da9/tutorial_aruco_board_detection.html">Detection of ArUco boards</a> <br  />
 </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"></th><th class="markdownTableHeadLeft"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">Original authors   </td><td class="markdownTableBodyLeft">Sergio Garrido, Alexander Panov    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">Compatibility   </td><td class="markdownTableBodyLeft">OpenCV &gt;= 4.7.0   </td></tr>
</table>
<p>Pose estimation is of great importance in many computer vision applications: robot navigation, augmented reality, and many more. This process is based on finding correspondences between points in the real environment and their 2d image projection. This is usually a difficult step, and thus it is common to use synthetic or fiducial markers to make it easier.</p>
<p>One of the most popular approaches is the use of binary square fiducial markers. The main benefit of these markers is that a single marker provides enough correspondences (its four corners) to obtain the camera pose. Also, the inner binary codification makes them specially robust, allowing the possibility of applying error detection and correction techniques.</p>
<p>The aruco module is based on the <a href="http://www.uco.es/investiga/grupos/ava/node/26" target="_blank">ArUco library</a>, a popular library for detection of square fiducial markers developed by Rafael Muñoz and Sergio Garrido <a class="el" href="../../d0/de3/citelist.html#CITEREF_Aruco2014">[99]</a>.</p>
<p>The aruco functionalities are included in: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d8/deb/aruco__detector_8hpp.html">opencv2/objdetect/aruco_detector.hpp</a>&gt;</span></div>
<div class="ttc" id="aaruco__detector_8hpp_html"><div class="ttname"><a href="../../d8/deb/aruco__detector_8hpp.html">aruco_detector.hpp</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1049"></a>
Markers and Dictionaries</h1>
<p>An ArUco marker is a synthetic square marker composed by a wide black border and an inner binary matrix which determines its identifier (id). The black border facilitates its fast detection in the image and the binary codification allows its identification and the application of error detection and correction techniques. The marker size determines the size of the internal matrix. For instance a marker size of 4x4 is composed by 16 bits.</p>
<p>Some examples of ArUco markers:</p>
<div class="image">
<img src="../../markers.jpg" alt=""/>
<div class="caption">
Example of markers images</div></div>
    <p>It must be noted that a marker can be found rotated in the environment, however, the detection process needs to be able to determine its original rotation, so that each corner is identified unequivocally. This is also done based on the binary codification.</p>
<p>A dictionary of markers is the set of markers that are considered in a specific application. It is simply the list of binary codifications of each of its markers.</p>
<p>The main properties of a dictionary are the dictionary size and the marker size.</p>
<ul>
<li>The dictionary size is the number of markers that compose the dictionary.</li>
<li>The marker size is the size of those markers (the number of bits/modules).</li>
</ul>
<p>The aruco module includes some predefined dictionaries covering a range of different dictionary sizes and marker sizes.</p>
<p>One may think that the marker id is the number obtained from converting the binary codification to a decimal base number. However, this is not possible since for high marker sizes the number of bits is too high and managing such huge numbers is not practical. Instead, a marker id is simply the marker index within the dictionary it belongs to. For instance, the first 5 markers in a dictionary have the ids: 0, 1, 2, 3 and 4.</p>
<p>More information about dictionaries is provided in the "Selecting a dictionary" section.</p>
<h1><a class="anchor" id="autotoc_md1050"></a>
Marker Creation</h1>
<p>Before their detection, markers need to be printed in order to be placed in the environment. Marker images can be generated using the <code>generateImageMarker()</code> function.</p>
<p>For example, lets analyze the following call:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a> markerImage;</div>
<div class="line"><a class="code hl_class" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html">cv::aruco::Dictionary</a> dictionary = <a class="code hl_function" href="../../de/d67/group__objdetect__aruco.html#ga68e0379bcf3799b1ff7145769f8a09c8">cv::aruco::getPredefinedDictionary</a>(<a class="code hl_enumvalue" href="../../de/d67/group__objdetect__aruco.html#gga4e13135a118f497c6172311d601ce00da6eb1a3e9c94c7123d8b1904a57193f16">cv::aruco::DICT_6X6_250</a>);</div>
<div class="line"><a class="code hl_function" href="../../de/d67/group__objdetect__aruco.html#ga631cb40c63945cc5b9ef6b064a5f4fc2">cv::aruco::generateImageMarker</a>(dictionary, 23, 200, markerImage, 1);</div>
<div class="line"><a class="code hl_function" href="../../d4/da8/group__imgcodecs.html#ga8ac397bd09e48851665edbe12aa28f25">cv::imwrite</a>(<span class="stringliteral">&quot;marker23.png&quot;</span>, markerImage);</div>
<div class="ttc" id="aclasscv_1_1Mat_html"><div class="ttname"><a href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a></div><div class="ttdoc">n-dimensional dense array class</div><div class="ttdef"><b>Definition</b> mat.hpp:812</div></div>
<div class="ttc" id="aclasscv_1_1aruco_1_1Dictionary_html"><div class="ttname"><a href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html">cv::aruco::Dictionary</a></div><div class="ttdoc">Dictionary is a set of unique ArUco markers of the same size.</div><div class="ttdef"><b>Definition</b> aruco_dictionary.hpp:29</div></div>
<div class="ttc" id="agroup__imgcodecs_html_ga8ac397bd09e48851665edbe12aa28f25"><div class="ttname"><a href="../../d4/da8/group__imgcodecs.html#ga8ac397bd09e48851665edbe12aa28f25">cv::imwrite</a></div><div class="ttdeci">CV_EXPORTS_W bool imwrite(const String &amp;filename, InputArray img, const std::vector&lt; int &gt; &amp;params=std::vector&lt; int &gt;())</div><div class="ttdoc">Saves an image to a specified file.</div></div>
<div class="ttc" id="agroup__objdetect__aruco_html_ga631cb40c63945cc5b9ef6b064a5f4fc2"><div class="ttname"><a href="../../de/d67/group__objdetect__aruco.html#ga631cb40c63945cc5b9ef6b064a5f4fc2">cv::aruco::generateImageMarker</a></div><div class="ttdeci">void generateImageMarker(const Dictionary &amp;dictionary, int id, int sidePixels, OutputArray img, int borderBits=1)</div><div class="ttdoc">Generate a canonical marker image.</div></div>
<div class="ttc" id="agroup__objdetect__aruco_html_ga68e0379bcf3799b1ff7145769f8a09c8"><div class="ttname"><a href="../../de/d67/group__objdetect__aruco.html#ga68e0379bcf3799b1ff7145769f8a09c8">cv::aruco::getPredefinedDictionary</a></div><div class="ttdeci">Dictionary getPredefinedDictionary(PredefinedDictionaryType name)</div><div class="ttdoc">Returns one of the predefined dictionaries defined in PredefinedDictionaryType.</div></div>
<div class="ttc" id="agroup__objdetect__aruco_html_gga4e13135a118f497c6172311d601ce00da6eb1a3e9c94c7123d8b1904a57193f16"><div class="ttname"><a href="../../de/d67/group__objdetect__aruco.html#gga4e13135a118f497c6172311d601ce00da6eb1a3e9c94c7123d8b1904a57193f16">cv::aruco::DICT_6X6_250</a></div><div class="ttdeci">@ DICT_6X6_250</div><div class="ttdoc">6x6 bits, minimum hamming distance between any two codes = 11, 250 codes</div><div class="ttdef"><b>Definition</b> aruco_dictionary.hpp:110</div></div>
</div><!-- fragment --><p>First, the <code><a class="el" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html" title="Dictionary is a set of unique ArUco markers of the same size.">cv::aruco::Dictionary</a></code> object is created by choosing one of the predefined dictionaries in the aruco module. Concretely, this dictionary is composed of 250 markers and a marker size of 6x6 bits (<code><a class="el" href="../../de/d67/group__objdetect__aruco.html#gga4e13135a118f497c6172311d601ce00da6eb1a3e9c94c7123d8b1904a57193f16" title="6x6 bits, minimum hamming distance between any two codes = 11, 250 codes">cv::aruco::DICT_6X6_250</a></code>).</p>
<p>The parameters of <code><a class="el" href="../../de/d67/group__objdetect__aruco.html#ga631cb40c63945cc5b9ef6b064a5f4fc2" title="Generate a canonical marker image.">cv::aruco::generateImageMarker()</a></code> are:</p>
<ul>
<li>The first parameter is the <code><a class="el" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html" title="Dictionary is a set of unique ArUco markers of the same size.">cv::aruco::Dictionary</a></code> object previously created.</li>
<li>The second parameter is the marker id, in this case the marker 23 of the dictionary <code><a class="el" href="../../de/d67/group__objdetect__aruco.html#gga4e13135a118f497c6172311d601ce00da6eb1a3e9c94c7123d8b1904a57193f16" title="6x6 bits, minimum hamming distance between any two codes = 11, 250 codes">cv::aruco::DICT_6X6_250</a></code>. Note that each dictionary is composed of a different number of markers. In this case, the valid ids go from 0 to 249. Any specific id out of the valid range will produce an exception.</li>
<li>The third parameter, 200, is the size of the output marker image. In this case, the output image will have a size of 200x200 pixels. Note that this parameter should be large enough to store the number of bits for the specific dictionary. So, for instance, you cannot generate an image of 5x5 pixels for a marker size of 6x6 bits (and that is without considering the marker border). Furthermore, to avoid deformations, this parameter should be proportional to the number of bits + border size, or at least much higher than the marker size (like 200 in the example), so that deformations are insignificant.</li>
<li>The fourth parameter is the output image.</li>
<li>Finally, the last parameter is an optional parameter to specify the width of the marker black border. The size is specified proportional to the number of bits. For instance a value of 2 means that the border will have a width equivalent to the size of two internal bits. The default value is 1.</li>
</ul>
<p>The generated image is:</p>
<div class="image">
<img src="../../marker23.png" alt=""/>
<div class="caption">
Generated marker</div></div>
    <p>A full working example is included in the <code>create_marker.cpp</code> inside the <code>samples/cpp/tutorial_code/objectDetection/</code>.</p>
<p>The samples now take input from the command line using <a class="el" href="../../d0/d2e/classcv_1_1CommandLineParser.html" title="Designed for command line parsing.">cv::CommandLineParser</a>. For this file the example parameters will look like: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;marker23.png&quot;</span> -d=10 -<span class="keywordtype">id</span>=23</div>
</div><!-- fragment --><p> Parameters for <code>create_marker.cpp</code>: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* keys  =</div>
<div class="line">        <span class="stringliteral">&quot;{@outfile |res.png| Output image }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{d        | 0     | dictionary: DICT_4X4_50=0, DICT_4X4_100=1, DICT_4X4_250=2,&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_4X4_1000=3, DICT_5X5_50=4, DICT_5X5_100=5, DICT_5X5_250=6, DICT_5X5_1000=7, &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_6X6_50=8, DICT_6X6_100=9, DICT_6X6_250=10, DICT_6X6_1000=11, DICT_7X7_50=12,&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_7X7_100=13, DICT_7X7_250=14, DICT_7X7_1000=15, DICT_ARUCO_ORIGINAL = 16}&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{cd       |       | Input file with custom dictionary }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{id       | 0     | Marker id in the dictionary }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{ms       | 200   | Marker size in pixels }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{bb       | 1     | Number of bits in marker borders }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{si       | false | show generated image }&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1051"></a>
Marker Detection</h1>
<p>Given an image containing ArUco markers, the detection process has to return a list of detected markers. Each detected marker includes:</p>
<ul>
<li>The position of its four corners in the image (in their original order).</li>
<li>The id of the marker.</li>
</ul>
<p>The marker detection process is comprised of two main steps:</p>
<ol type="1">
<li>Detection of marker candidates. In this step the image is analyzed in order to find square shapes that are candidates to be markers. It begins with an adaptive thresholding to segment the markers, then contours are extracted from the thresholded image and those that are not convex or do not approximate to a square shape are discarded. Some extra filtering is also applied (removing contours that are too small or too big, removing contours too close to each other, etc).</li>
<li>After the candidate detection, it is necessary to determine if they are actually markers by analyzing their inner codification. This step starts by extracting the marker bits of each marker. To do so, a perspective transformation is first applied to obtain the marker in its canonical form. Then, the canonical image is thresholded using Otsu to separate white and black bits. The image is divided into different cells according to the marker size and the border size. Then the number of black or white pixels in each cell is counted to determine if it is a white or a black bit. Finally, the bits are analyzed to determine if the marker belongs to the specific dictionary. Error correction techniques are employed when necessary.</li>
</ol>
<p>Consider the following image:</p>
<div class="image">
<img src="../../singlemarkerssource.jpg" alt=""/>
<div class="caption">
Image with an assortment of markers</div></div>
    <p>And a printout of this image in a photo:</p>
<div class="image">
<img src="../../singlemarkersoriginal.jpg" alt=""/>
<div class="caption">
Original image with markers</div></div>
    <p>These are the detected markers (in green). Note that some markers are rotated. The small red square indicates the marker’s top left corner:</p>
<div class="image">
<img src="../../singlemarkersdetection.jpg" alt=""/>
<div class="caption">
Image with detected markers</div></div>
    <p>And these are the marker candidates that have been rejected during the identification step (in pink):</p>
<div class="image">
<img src="../../singlemarkersrejected.jpg" alt=""/>
<div class="caption">
Image with rejected candidates</div></div>
    <p>In the aruco module, the detection is performed in the <code><a class="el" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html#a0c1d14251bf1cbb06277f49cfe1c9b61" title="Basic marker detection.">cv::aruco::ArucoDetector::detectMarkers()</a></code> function. This function is the most important in the module, since all the rest of the functionality is based on the detected markers returned by <code><a class="el" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html#a0c1d14251bf1cbb06277f49cfe1c9b61" title="Basic marker detection.">cv::aruco::ArucoDetector::detectMarkers()</a></code>.</p>
<p>An example of marker detection:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a> inputImage;</div>
<div class="line"><span class="comment">// ... read inputImage ...</span></div>
<div class="line">std::vector&lt;int&gt; markerIds;</div>
<div class="line">std::vector&lt;std::vector&lt;cv::Point2f&gt;&gt; markerCorners, rejectedCandidates;</div>
<div class="line"><a class="code hl_struct" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html">cv::aruco::DetectorParameters</a> detectorParams = <a class="code hl_struct" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html">cv::aruco::DetectorParameters</a>();</div>
<div class="line"><a class="code hl_class" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html">cv::aruco::Dictionary</a> dictionary = <a class="code hl_function" href="../../de/d67/group__objdetect__aruco.html#ga68e0379bcf3799b1ff7145769f8a09c8">cv::aruco::getPredefinedDictionary</a>(<a class="code hl_enumvalue" href="../../de/d67/group__objdetect__aruco.html#gga4e13135a118f497c6172311d601ce00da6eb1a3e9c94c7123d8b1904a57193f16">cv::aruco::DICT_6X6_250</a>);</div>
<div class="line"><a class="code hl_class" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html">cv::aruco::ArucoDetector</a> detector(dictionary, detectorParams);</div>
<div class="line">detector.detectMarkers(inputImage, markerCorners, markerIds, rejectedCandidates);</div>
<div class="ttc" id="aclasscv_1_1aruco_1_1ArucoDetector_html"><div class="ttname"><a href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html">cv::aruco::ArucoDetector</a></div><div class="ttdoc">The main functionality of ArucoDetector class is detection of markers in an image with detectMarkers(...</div><div class="ttdef"><b>Definition</b> aruco_detector.hpp:276</div></div>
<div class="ttc" id="astructcv_1_1aruco_1_1DetectorParameters_html"><div class="ttname"><a href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html">cv::aruco::DetectorParameters</a></div><div class="ttdoc">struct DetectorParameters is used by ArucoDetector</div><div class="ttdef"><b>Definition</b> aruco_detector.hpp:25</div></div>
</div><!-- fragment --><p>When you create an <code><a class="el" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html" title="The main functionality of ArucoDetector class is detection of markers in an image with detectMarkers(...">cv::aruco::ArucoDetector</a></code> object, you need to pass the following parameters to the constructor:</p>
<ul>
<li>A dictionary object, in this case one of the predefined dictionaries (<code><a class="el" href="../../de/d67/group__objdetect__aruco.html#gga4e13135a118f497c6172311d601ce00da6eb1a3e9c94c7123d8b1904a57193f16" title="6x6 bits, minimum hamming distance between any two codes = 11, 250 codes">cv::aruco::DICT_6X6_250</a></code>).</li>
<li>Object of type <code><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html" title="struct DetectorParameters is used by ArucoDetector">cv::aruco::DetectorParameters</a></code>. This object includes all parameters that can be customized during the detection process. These parameters will be explained in the next section.</li>
</ul>
<p>The parameters of <code><a class="el" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html#a0c1d14251bf1cbb06277f49cfe1c9b61" title="Basic marker detection.">cv::aruco::ArucoDetector::detectMarkers()</a></code> are:</p>
<ul>
<li>The first parameter is the image containing the markers to be detected.</li>
<li>The detected markers are stored in the <code>markerCorners</code> and <code>markerIds</code> structures:<ul>
<li><code>markerCorners</code> is the list of corners of the detected markers. For each marker, its four corners are returned in their original order (which is clockwise starting with top left). So, the first corner is the top left corner, followed by the top right, bottom right and bottom left.</li>
<li><code>markerIds</code> is the list of ids of each of the detected markers in <code>markerCorners</code>. Note that the returned <code>markerCorners</code> and <code>markerIds</code> vectors have the same size.</li>
</ul>
</li>
<li>The final optional parameter, <code>rejectedCandidates</code>, is a returned list of marker candidates, i.e. shapes that were found and considered but did not contain a valid marker. Each candidate is also defined by its four corners, and its format is the same as the <code>markerCorners</code> parameter. This parameter can be omitted and is only useful for debugging purposes and for ‘refind’ strategies (see <code><a class="el" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html#ad806c9310cfc826a178b0aefdf09bab6" title="Refine not detected markers based on the already detected and the board layout.">cv::aruco::ArucoDetector::refineDetectedMarkers()</a></code>).</li>
</ul>
<p>The next thing you probably want to do after <code><a class="el" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html#a0c1d14251bf1cbb06277f49cfe1c9b61" title="Basic marker detection.">cv::aruco::ArucoDetector::detectMarkers()</a></code> is check that your markers have been correctly detected. Fortunately, the aruco module provides a function to draw the detected markers in the input image, this function is <code>drawDetectedMarkers()</code>. For example:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a> outputImage = inputImage.<a class="code hl_function" href="../../d3/d63/classcv_1_1Mat.html#a03d2a2570d06dcae378f788725789aa4">clone</a>();</div>
<div class="line"><a class="code hl_function" href="../../de/d67/group__objdetect__aruco.html#ga2ad34b0f277edebb6a132d3069ed2909">cv::aruco::drawDetectedMarkers</a>(outputImage, markerCorners, markerIds);</div>
<div class="ttc" id="aclasscv_1_1Mat_html_a03d2a2570d06dcae378f788725789aa4"><div class="ttname"><a href="../../d3/d63/classcv_1_1Mat.html#a03d2a2570d06dcae378f788725789aa4">cv::Mat::clone</a></div><div class="ttdeci">CV_NODISCARD_STD Mat clone() const</div><div class="ttdoc">Creates a full copy of the array and the underlying data.</div></div>
<div class="ttc" id="agroup__objdetect__aruco_html_ga2ad34b0f277edebb6a132d3069ed2909"><div class="ttname"><a href="../../de/d67/group__objdetect__aruco.html#ga2ad34b0f277edebb6a132d3069ed2909">cv::aruco::drawDetectedMarkers</a></div><div class="ttdeci">void drawDetectedMarkers(InputOutputArray image, InputArrayOfArrays corners, InputArray ids=noArray(), Scalar borderColor=Scalar(0, 255, 0))</div><div class="ttdoc">Draw detected markers in image.</div></div>
</div><!-- fragment --><ul>
<li><code>outputImage</code> is the input/output image where the markers will be drawn (it will normally be the same as the image where the markers were detected).</li>
<li><code>markerCorners</code> and <code>markerIds</code> are the structures of the detected markers returned by the <code><a class="el" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html#a0c1d14251bf1cbb06277f49cfe1c9b61" title="Basic marker detection.">cv::aruco::ArucoDetector::detectMarkers()</a></code> function.</li>
</ul>
<div class="image">
<img src="../../singlemarkersdetection.jpg" alt=""/>
<div class="caption">
Image with detected markers</div></div>
    <p>Note that this function is only provided for visualization and its use can be omitted.</p>
<p>With these two functions we can create a basic marker detection loop to detect markers from our camera:</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html">cv::aruco::ArucoDetector</a> detector(dictionary, detectorParams);</div>
<div class="line">    <a class="code hl_class" href="../../d8/dfe/classcv_1_1VideoCapture.html">cv::VideoCapture</a> inputVideo;</div>
<div class="line">    <span class="keywordtype">int</span> waitTime;</div>
<div class="line">    <span class="keywordflow">if</span>(!video.empty()) {</div>
<div class="line">        inputVideo.<a class="code hl_function" href="../../d8/dfe/classcv_1_1VideoCapture.html#a614a1702e15f42ede5100014ce7f48ed">open</a>(video);</div>
<div class="line">        waitTime = 0;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        inputVideo.<a class="code hl_function" href="../../d8/dfe/classcv_1_1VideoCapture.html#a614a1702e15f42ede5100014ce7f48ed">open</a>(camId);</div>
<div class="line">        waitTime = 10;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> totalTime = 0;</div>
<div class="line">    <span class="keywordtype">int</span> totalIterations = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// set coordinate system</span></div>
<div class="line">    <a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a> objPoints(4, 1, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga0610d99405b809062622588c25ed5c8f">CV_32FC3</a>);</div>
<div class="line">    objPoints.ptr&lt;Vec3f&gt;(0)[0] = Vec3f(-markerLength/2.f, markerLength/2.f, 0);</div>
<div class="line">    objPoints.ptr&lt;Vec3f&gt;(0)[1] = Vec3f(markerLength/2.f, markerLength/2.f, 0);</div>
<div class="line">    objPoints.ptr&lt;Vec3f&gt;(0)[2] = Vec3f(markerLength/2.f, -markerLength/2.f, 0);</div>
<div class="line">    objPoints.ptr&lt;Vec3f&gt;(0)[3] = Vec3f(-markerLength/2.f, -markerLength/2.f, 0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span>(inputVideo.<a class="code hl_function" href="../../d8/dfe/classcv_1_1VideoCapture.html#ae38c2a053d39d6b20c9c649e08ff0146">grab</a>()) {</div>
<div class="line">        <a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a> image, imageCopy;</div>
<div class="line">        inputVideo.<a class="code hl_function" href="../../d8/dfe/classcv_1_1VideoCapture.html#a9ac7f4b1cdfe624663478568486e6712">retrieve</a>(image);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">double</span> tick = (double)getTickCount();</div>
<div class="line"> </div>
<div class="line">        vector&lt;int&gt; ids;</div>
<div class="line">        vector&lt;vector&lt;Point2f&gt; &gt; corners, rejected;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// detect markers and estimate pose</span></div>
<div class="line">        detector.detectMarkers(image, corners, ids, rejected);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">size_t</span> nMarkers = corners.size();</div>
<div class="line">        vector&lt;Vec3d&gt; rvecs(nMarkers), tvecs(nMarkers);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(estimatePose &amp;&amp; !ids.empty()) {</div>
<div class="line">            <span class="comment">// Calculate pose for each marker</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nMarkers; i++) {</div>
<div class="line">                solvePnP(objPoints, corners.at(i), camMatrix, distCoeffs, rvecs.at(i), tvecs.at(i));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordtype">double</span> currentTime = ((double)<a class="code hl_function" href="../../db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">getTickCount</a>() - tick) / <a class="code hl_function" href="../../db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c">getTickFrequency</a>();</div>
<div class="line">        totalTime += currentTime;</div>
<div class="line">        totalIterations++;</div>
<div class="line">        <span class="keywordflow">if</span>(totalIterations % 30 == 0) {</div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;Detection Time = &quot;</span> &lt;&lt; currentTime * 1000 &lt;&lt; <span class="stringliteral">&quot; ms &quot;</span></div>
<div class="line">                 &lt;&lt; <span class="stringliteral">&quot;(Mean = &quot;</span> &lt;&lt; 1000 * totalTime / double(totalIterations) &lt;&lt; <span class="stringliteral">&quot; ms)&quot;</span> &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// draw results</span></div>
<div class="line">        image.<a class="code hl_function" href="../../d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77">copyTo</a>(imageCopy);</div>
<div class="line">        <span class="keywordflow">if</span>(!ids.empty()) {</div>
<div class="line">            <a class="code hl_function" href="../../de/d67/group__objdetect__aruco.html#ga2ad34b0f277edebb6a132d3069ed2909">cv::aruco::drawDetectedMarkers</a>(imageCopy, corners, ids);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span>(estimatePose) {</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; ids.size(); i++)</div>
<div class="line">                    <a class="code hl_function" href="../../d9/d0c/group__calib3d.html#gab3ab7bb2bdfe7d5d9745bb92d13f9564">cv::drawFrameAxes</a>(imageCopy, camMatrix, distCoeffs, rvecs[i], tvecs[i], markerLength * 1.5f, 2);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(showRejected &amp;&amp; !rejected.empty())</div>
<div class="line">            <a class="code hl_function" href="../../de/d67/group__objdetect__aruco.html#ga2ad34b0f277edebb6a132d3069ed2909">cv::aruco::drawDetectedMarkers</a>(imageCopy, rejected, <a class="code hl_function" href="../../dc/d84/group__core__basic.html#gad9287b23bba2fed753b36ef561ae7346">noArray</a>(), <a class="code hl_typedef" href="../../dc/d84/group__core__basic.html#ga599fe92e910c027be274233eccad7beb">Scalar</a>(100, 0, 255));</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="../../d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">imshow</a>(<span class="stringliteral">&quot;out&quot;</span>, imageCopy);</div>
<div class="line">        <span class="keywordtype">char</span> key = (char)<a class="code hl_function" href="../../d7/dfc/group__highgui.html#ga5628525ad33f52eab17feebcfba38bd7">waitKey</a>(waitTime);</div>
<div class="line">        <span class="keywordflow">if</span>(key == 27) <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="ttc" id="aclasscv_1_1Mat_html_a33fd5d125b4c302b0c9aa86980791a77"><div class="ttname"><a href="../../d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77">cv::Mat::copyTo</a></div><div class="ttdeci">void copyTo(OutputArray m) const</div><div class="ttdoc">Copies the matrix to another one.</div></div>
<div class="ttc" id="aclasscv_1_1VideoCapture_html"><div class="ttname"><a href="../../d8/dfe/classcv_1_1VideoCapture.html">cv::VideoCapture</a></div><div class="ttdoc">Class for video capturing from video files, image sequences or cameras.</div><div class="ttdef"><b>Definition</b> videoio.hpp:731</div></div>
<div class="ttc" id="aclasscv_1_1VideoCapture_html_a614a1702e15f42ede5100014ce7f48ed"><div class="ttname"><a href="../../d8/dfe/classcv_1_1VideoCapture.html#a614a1702e15f42ede5100014ce7f48ed">cv::VideoCapture::open</a></div><div class="ttdeci">virtual bool open(const String &amp;filename, int apiPreference=CAP_ANY)</div><div class="ttdoc">Opens a video file or a capturing device or an IP video stream for video capturing.</div></div>
<div class="ttc" id="aclasscv_1_1VideoCapture_html_a9ac7f4b1cdfe624663478568486e6712"><div class="ttname"><a href="../../d8/dfe/classcv_1_1VideoCapture.html#a9ac7f4b1cdfe624663478568486e6712">cv::VideoCapture::retrieve</a></div><div class="ttdeci">virtual bool retrieve(OutputArray image, int flag=0)</div><div class="ttdoc">Decodes and returns the grabbed video frame.</div></div>
<div class="ttc" id="aclasscv_1_1VideoCapture_html_ae38c2a053d39d6b20c9c649e08ff0146"><div class="ttname"><a href="../../d8/dfe/classcv_1_1VideoCapture.html#ae38c2a053d39d6b20c9c649e08ff0146">cv::VideoCapture::grab</a></div><div class="ttdeci">virtual bool grab()</div><div class="ttdoc">Grabs the next frame from video file or capturing device.</div></div>
<div class="ttc" id="agroup__calib3d_html_gab3ab7bb2bdfe7d5d9745bb92d13f9564"><div class="ttname"><a href="../../d9/d0c/group__calib3d.html#gab3ab7bb2bdfe7d5d9745bb92d13f9564">cv::drawFrameAxes</a></div><div class="ttdeci">void drawFrameAxes(InputOutputArray image, InputArray cameraMatrix, InputArray distCoeffs, InputArray rvec, InputArray tvec, float length, int thickness=3)</div><div class="ttdoc">Draw axes of the world/object coordinate system from pose estimation.</div></div>
<div class="ttc" id="agroup__core__basic_html_ga599fe92e910c027be274233eccad7beb"><div class="ttname"><a href="../../dc/d84/group__core__basic.html#ga599fe92e910c027be274233eccad7beb">cv::Scalar</a></div><div class="ttdeci">Scalar_&lt; double &gt; Scalar</div><div class="ttdef"><b>Definition</b> types.hpp:702</div></div>
<div class="ttc" id="agroup__core__basic_html_gad9287b23bba2fed753b36ef561ae7346"><div class="ttname"><a href="../../dc/d84/group__core__basic.html#gad9287b23bba2fed753b36ef561ae7346">cv::noArray</a></div><div class="ttdeci">InputOutputArray noArray()</div></div>
<div class="ttc" id="agroup__core__hal__interface_html_ga0610d99405b809062622588c25ed5c8f"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#ga0610d99405b809062622588c25ed5c8f">CV_32FC3</a></div><div class="ttdeci">#define CV_32FC3</div><div class="ttdef"><b>Definition</b> interface.h:120</div></div>
<div class="ttc" id="agroup__core__utils_html_ga705441a9ef01f47acdc55d87fbe5090c"><div class="ttname"><a href="../../db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c">cv::getTickFrequency</a></div><div class="ttdeci">double getTickFrequency()</div><div class="ttdoc">Returns the number of ticks per second.</div></div>
<div class="ttc" id="agroup__core__utils_html_gae73f58000611a1af25dd36d496bf4487"><div class="ttname"><a href="../../db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">cv::getTickCount</a></div><div class="ttdeci">int64 getTickCount()</div><div class="ttdoc">Returns the number of ticks.</div></div>
<div class="ttc" id="agroup__highgui_html_ga453d42fe4cb60e5723281a89973ee563"><div class="ttname"><a href="../../d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">cv::imshow</a></div><div class="ttdeci">void imshow(const String &amp;winname, InputArray mat)</div><div class="ttdoc">Displays an image in the specified window.</div></div>
<div class="ttc" id="agroup__highgui_html_ga5628525ad33f52eab17feebcfba38bd7"><div class="ttname"><a href="../../d7/dfc/group__highgui.html#ga5628525ad33f52eab17feebcfba38bd7">cv::waitKey</a></div><div class="ttdeci">int waitKey(int delay=0)</div><div class="ttdoc">Waits for a pressed key.</div></div>
</div><!-- fragment --><p>Note that some of the optional parameters have been omitted, like the detection parameter object and the output vector of rejected candidates.</p>
<p>A full working example is included in the <code>detect_markers.cpp</code> inside the <code>samples/cpp/tutorial_code/objectDetection/</code>.</p>
<p>The samples now take input from the command line using <a class="el" href="../../d0/d2e/classcv_1_1CommandLineParser.html" title="Designed for command line parsing.">cv::CommandLineParser</a>. For this file the example parameters will look like: </p><div class="fragment"><div class="line">-v=/path_to_opencv/opencv/doc/tutorials/objdetect/aruco_detection/images/singlemarkersoriginal.jpg -d=10</div>
</div><!-- fragment --><p> Parameters for <code>detect_markers.cpp</code>: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* keys  =</div>
<div class="line">        <span class="stringliteral">&quot;{d        | 0     | dictionary: DICT_4X4_50=0, DICT_4X4_100=1, DICT_4X4_250=2,&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_4X4_1000=3, DICT_5X5_50=4, DICT_5X5_100=5, DICT_5X5_250=6, DICT_5X5_1000=7, &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_6X6_50=8, DICT_6X6_100=9, DICT_6X6_250=10, DICT_6X6_1000=11, DICT_7X7_50=12,&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_7X7_100=13, DICT_7X7_250=14, DICT_7X7_1000=15, DICT_ARUCO_ORIGINAL = 16,&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_APRILTAG_16h5=17, DICT_APRILTAG_25h9=18, DICT_APRILTAG_36h10=19, DICT_APRILTAG_36h11=20}&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{cd       |       | Input file with custom dictionary }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{v        |       | Input from video or image file, if ommited, input comes from camera }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{ci       | 0     | Camera id if input doesnt come from video (-v) }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{c        |       | Camera intrinsic parameters. Needed for camera pose }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{l        | 0.1   | Marker side length (in meters). Needed for correct scale in camera pose }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{dp       |       | File of marker detector parameters }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{r        |       | show rejected candidates too }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{refine   |       | Corner refinement: CORNER_REFINE_NONE=0, CORNER_REFINE_SUBPIX=1,&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;CORNER_REFINE_CONTOUR=2, CORNER_REFINE_APRILTAG=3}&quot;</span>;</div>
<div class="line"> </div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1052"></a>
Pose Estimation</h1>
<p>The next thing you'll probably want to do after detecting the markers is to use them to get the camera pose.</p>
<p>To perform camera pose estimation, you need to know your camera's calibration parameters. These are the camera matrix and distortion coefficients. If you do not know how to calibrate your camera, you can take a look at the <code>calibrateCamera()</code> function and the Calibration tutorial of OpenCV. You can also calibrate your camera using the aruco module as explained in the <b>Calibration with ArUco and ChArUco</b> tutorial. Note that this only needs to be done once unless the camera optics are modified (for instance changing its focus).</p>
<p>As a result of the calibration, you get a camera matrix: a matrix of 3x3 elements with the focal distances and the camera center coordinates (a.k.a intrinsic parameters), and the distortion coefficients: a vector of 5 or more elements that models the distortion produced by your camera.</p>
<p>When you estimate the pose with ArUco markers, you can estimate the pose of each marker individually. If you want to estimate one pose from a set of markers, use ArUco Boards (see the <b>Detection of ArUco Boards</b> tutorial). Using ArUco boards instead of single markers allows some markers to be occluded.</p>
<p>The camera pose relative to the marker is a 3d transformation from the marker coordinate system to the camera coordinate system. It is specified by rotation and translation vectors. OpenCV provides <code><a class="el" href="../../d9/d0c/group__calib3d.html#ga549c2075fac14829ff4a58bc931c033d" title="Finds an object pose from 3D-2D point correspondences.">cv::solvePnP()</a></code> function to do that.</p>
<div class="fragment"><div class="line">    Mat camMatrix, distCoeffs;</div>
<div class="line">    <span class="keywordflow">if</span>(estimatePose) {</div>
<div class="line">        <span class="comment">// You can read camera parameters from tutorial_camera_params.yml</span></div>
<div class="line">        readCameraParamsFromCommandLine(parser, camMatrix, distCoeffs);</div>
<div class="line">    }</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// set coordinate system</span></div>
<div class="line">    <a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a> objPoints(4, 1, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga0610d99405b809062622588c25ed5c8f">CV_32FC3</a>);</div>
<div class="line">    objPoints.ptr&lt;Vec3f&gt;(0)[0] = Vec3f(-markerLength/2.f, markerLength/2.f, 0);</div>
<div class="line">    objPoints.ptr&lt;Vec3f&gt;(0)[1] = Vec3f(markerLength/2.f, markerLength/2.f, 0);</div>
<div class="line">    objPoints.ptr&lt;Vec3f&gt;(0)[2] = Vec3f(markerLength/2.f, -markerLength/2.f, 0);</div>
<div class="line">    objPoints.ptr&lt;Vec3f&gt;(0)[3] = Vec3f(-markerLength/2.f, -markerLength/2.f, 0);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">        vector&lt;int&gt; ids;</div>
<div class="line">        vector&lt;vector&lt;Point2f&gt; &gt; corners, rejected;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// detect markers and estimate pose</span></div>
<div class="line">        detector.detectMarkers(image, corners, ids, rejected);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">size_t</span> nMarkers = corners.size();</div>
<div class="line">        vector&lt;Vec3d&gt; rvecs(nMarkers), tvecs(nMarkers);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(estimatePose &amp;&amp; !ids.empty()) {</div>
<div class="line">            <span class="comment">// Calculate pose for each marker</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nMarkers; i++) {</div>
<div class="line">                solvePnP(objPoints, corners.at(i), camMatrix, distCoeffs, rvecs.at(i), tvecs.at(i));</div>
<div class="line">            }</div>
<div class="line">        }</div>
</div><!-- fragment --><ul>
<li>The <code>corners</code> parameter is the vector of marker corners returned by the <code><a class="el" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html#a0c1d14251bf1cbb06277f49cfe1c9b61" title="Basic marker detection.">cv::aruco::ArucoDetector::detectMarkers()</a></code> function.</li>
<li>The second parameter is the size of the marker side in meters or in any other unit. Note that the translation vectors of the estimated poses will be in the same units.</li>
<li><code>camMatrix</code> and <code>distCoeffs</code> are the camera calibration parameters that were created during the camera calibration process.</li>
<li>The output parameters <code>rvecs</code> and <code>tvecs</code> are the rotation and translation vectors respectively, for each of the detected markers in <code>corners</code>.</li>
</ul>
<p>The marker coordinate system that is assumed by this function is placed in the center (by default) or in the top left corner of the marker with the Z axis pointing out, as in the following image. Axis-color correspondences are X: red, Y: green, Z: blue. Note the axis directions of the rotated markers in this image.</p>
<div class="image">
<img src="../../singlemarkersaxes.jpg" alt=""/>
<div class="caption">
Image with axes drawn</div></div>
    <p>OpenCV provides a function to draw the axis as in the image above, so pose estimation can be checked:</p>
<div class="fragment"><div class="line">        <span class="comment">// draw results</span></div>
<div class="line">        image.<a class="code hl_function" href="../../d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77">copyTo</a>(imageCopy);</div>
<div class="line">        <span class="keywordflow">if</span>(!ids.empty()) {</div>
<div class="line">            <a class="code hl_function" href="../../de/d67/group__objdetect__aruco.html#ga2ad34b0f277edebb6a132d3069ed2909">cv::aruco::drawDetectedMarkers</a>(imageCopy, corners, ids);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span>(estimatePose) {</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; ids.size(); i++)</div>
<div class="line">                    <a class="code hl_function" href="../../d9/d0c/group__calib3d.html#gab3ab7bb2bdfe7d5d9745bb92d13f9564">cv::drawFrameAxes</a>(imageCopy, camMatrix, distCoeffs, rvecs[i], tvecs[i], markerLength * 1.5f, 2);</div>
<div class="line">            }</div>
<div class="line">        }</div>
</div><!-- fragment --><ul>
<li><code>imageCopy</code> is the input/output image where the detected markers will be shown.</li>
<li><code>camMatrix</code> and <code>distCoeffs</code> are the camera calibration parameters.</li>
<li><code>rvecs[i]</code> and <code>tvecs[i]</code> are the rotation and translation vectors respectively, for each of the detected markers.</li>
<li>The last parameter is the length of the axis, in the same unit as tvec (usually meters).</li>
</ul>
<p>Sample video:</p>
<div align='center'><iframe title='Video' width='560' height='349' src='https://www.youtube.com/embed/IsXWrcB_Hvs?rel=0' frameborder='0' align='middle' allowfullscreen></iframe></div><p>A full working example is included in the <code>detect_markers.cpp</code> inside the <code>samples/cpp/tutorial_code/objectDetection/</code>.</p>
<p>The samples now take input from the command line using <a class="el" href="../../d0/d2e/classcv_1_1CommandLineParser.html" title="Designed for command line parsing.">cv::CommandLineParser</a>. For this file the example parameters will look like: </p><div class="fragment"><div class="line">-v=/path_to_opencv/opencv/doc/tutorials/objdetect/aruco_detection/images/singlemarkersoriginal.jpg -d=10</div>
<div class="line">-c=/path_to_opencv/opencv/samples/cpp/tutorial_code/objectDetection/tutorial_camera_params.yml</div>
</div><!-- fragment --><p> Parameters for <code>detect_markers.cpp</code>: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* keys  =</div>
<div class="line">        <span class="stringliteral">&quot;{d        | 0     | dictionary: DICT_4X4_50=0, DICT_4X4_100=1, DICT_4X4_250=2,&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_4X4_1000=3, DICT_5X5_50=4, DICT_5X5_100=5, DICT_5X5_250=6, DICT_5X5_1000=7, &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_6X6_50=8, DICT_6X6_100=9, DICT_6X6_250=10, DICT_6X6_1000=11, DICT_7X7_50=12,&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_7X7_100=13, DICT_7X7_250=14, DICT_7X7_1000=15, DICT_ARUCO_ORIGINAL = 16,&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;DICT_APRILTAG_16h5=17, DICT_APRILTAG_25h9=18, DICT_APRILTAG_36h10=19, DICT_APRILTAG_36h11=20}&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{cd       |       | Input file with custom dictionary }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{v        |       | Input from video or image file, if ommited, input comes from camera }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{ci       | 0     | Camera id if input doesnt come from video (-v) }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{c        |       | Camera intrinsic parameters. Needed for camera pose }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{l        | 0.1   | Marker side length (in meters). Needed for correct scale in camera pose }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{dp       |       | File of marker detector parameters }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{r        |       | show rejected candidates too }&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;{refine   |       | Corner refinement: CORNER_REFINE_NONE=0, CORNER_REFINE_SUBPIX=1,&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;CORNER_REFINE_CONTOUR=2, CORNER_REFINE_APRILTAG=3}&quot;</span>;</div>
<div class="line"> </div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1053"></a>
Selecting a dictionary</h1>
<p>The aruco module provides the <code>Dictionary</code> class to represent a dictionary of markers.</p>
<p>In addition to the marker size and the number of markers in the dictionary, there is another important parameter of the dictionary - the inter-marker distance. The inter-marker distance is the minimum Hamming distance between dictionary markers that determines the dictionary's ability to detect and correct errors.</p>
<p>In general, smaller dictionary sizes and larger marker sizes increase the inter-marker distance and vice versa. However, the detection of markers with larger sizes is more difficult due to the higher number of bits that need to be extracted from the image.</p>
<p>For instance, if you need only 10 markers in your application, it is better to use a dictionary composed only of those 10 markers than using a dictionary composed of 1000 markers. The reason is that the dictionary composed of 10 markers will have a higher inter-marker distance and, thus, it will be more robust to errors.</p>
<p>As a consequence, the aruco module includes several ways to select your dictionary of markers, so that you can increase your system robustness:</p>
<h2><a class="anchor" id="autotoc_md1054"></a>
Predefined dictionaries</h2>
<p>This is the easiest way to select a dictionary. The aruco module includes a set of predefined dictionaries in a variety of marker sizes and number of markers. For instance:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html">cv::aruco::Dictionary</a> dictionary = <a class="code hl_function" href="../../de/d67/group__objdetect__aruco.html#ga68e0379bcf3799b1ff7145769f8a09c8">cv::aruco::getPredefinedDictionary</a>(<a class="code hl_enumvalue" href="../../de/d67/group__objdetect__aruco.html#gga4e13135a118f497c6172311d601ce00da6eb1a3e9c94c7123d8b1904a57193f16">cv::aruco::DICT_6X6_250</a>);</div>
</div><!-- fragment --><p><code><a class="el" href="../../de/d67/group__objdetect__aruco.html#gga4e13135a118f497c6172311d601ce00da6eb1a3e9c94c7123d8b1904a57193f16" title="6x6 bits, minimum hamming distance between any two codes = 11, 250 codes">cv::aruco::DICT_6X6_250</a></code> is an example of predefined dictionary of markers with 6x6 bits and a total of 250 markers.</p>
<p>From all the provided dictionaries, it is recommended to choose the smallest one that fits your application. For instance, if you need 200 markers of 6x6 bits, it is better to use <code><a class="el" href="../../de/d67/group__objdetect__aruco.html#gga4e13135a118f497c6172311d601ce00da6eb1a3e9c94c7123d8b1904a57193f16" title="6x6 bits, minimum hamming distance between any two codes = 11, 250 codes">cv::aruco::DICT_6X6_250</a></code> than <code><a class="el" href="../../de/d67/group__objdetect__aruco.html#gga4e13135a118f497c6172311d601ce00da9f3ab829fb35fc9ff30e8f809d318e03" title="6x6 bits, minimum hamming distance between any two codes = 9, 1000 codes">cv::aruco::DICT_6X6_1000</a></code>. The smaller the dictionary, the higher the inter-marker distance.</p>
<p>The list of available predefined dictionaries can be found in the documentation for the <code>PredefinedDictionaryType</code> enum.</p>
<h2><a class="anchor" id="autotoc_md1055"></a>
Automatic dictionary generation</h2>
<p>A dictionary can be generated automatically to adjust the desired number of markers and bits to optimize the inter-marker distance:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html">cv::aruco::Dictionary</a> dictionary = <a class="code hl_function" href="../../de/d67/group__objdetect__aruco.html#ga928c031e9a782b18405af56c851d9549">cv::aruco::extendDictionary</a>(36, 5);</div>
<div class="ttc" id="agroup__objdetect__aruco_html_ga928c031e9a782b18405af56c851d9549"><div class="ttname"><a href="../../de/d67/group__objdetect__aruco.html#ga928c031e9a782b18405af56c851d9549">cv::aruco::extendDictionary</a></div><div class="ttdeci">Dictionary extendDictionary(int nMarkers, int markerSize, const Dictionary &amp;baseDictionary=Dictionary(), int randomSeed=0)</div><div class="ttdoc">Extend base dictionary by new nMarkers.</div></div>
</div><!-- fragment --><p>This will generate a customized dictionary composed of 36 markers of 5x5 bits. The process can take several seconds, depending on the parameters (it is slower for larger dictionaries and higher numbers of bits).</p>
<p>Also you could use <code>aruco_dict_utils.cpp</code> sample inside the <code>opencv/samples/cpp</code>. This sample calculates the minimum Hamming distance for the generated dictionary and also allows you to create markers that are resistant to reflection.</p>
<h2><a class="anchor" id="autotoc_md1056"></a>
Manual dictionary definition</h2>
<p>Finally, the dictionary can be configured manually, so that any encoding can be used. To do that, the <code><a class="el" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html" title="Dictionary is a set of unique ArUco markers of the same size.">cv::aruco::Dictionary</a></code> object parameters need to be assigned manually. It must be noted that, unless you have a special reason to do this manually, it is preferable to use one of the previous alternatives.</p>
<p>The <code><a class="el" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html" title="Dictionary is a set of unique ArUco markers of the same size.">cv::aruco::Dictionary</a></code> parameters are:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Dictionary {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a> bytesList;      <span class="comment">// marker code information</span></div>
<div class="line">    <span class="keywordtype">int</span> markerSize;         <span class="comment">// number of bits per dimension</span></div>
<div class="line">    <span class="keywordtype">int</span> maxCorrectionBits;  <span class="comment">// maximum number of bits that can be corrected</span></div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p><code>bytesList</code> is the array that contains all the information about the marker codes. <code>markerSize</code> is the size of each marker dimension (for instance, 5 for markers with 5x5 bits). Finally, <code>maxCorrectionBits</code> is the maximum number of erroneous bits that can be corrected during the marker detection. If this value is too high, it can lead to a high number of false positives.</p>
<p>Each row in <code>bytesList</code> represents one of the dictionary markers. However, the markers are not stored in their binary form, instead they are stored in a special format to simplify their detection.</p>
<p>Fortunately, a marker can be easily transformed to this form using the static method <code>Dictionary::getByteListFromBits()</code>.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html">cv::aruco::Dictionary</a> dictionary;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Markers of 6x6 bits</span></div>
<div class="line">dictionary.<a class="code hl_variable" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html#a996eb5d27e061fedf0550092a6149ed7">markerSize</a> = 6;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Maximum number of bit corrections</span></div>
<div class="line">dictionary.<a class="code hl_variable" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html#a729196b33a1a678a82f01f8e15d7864b">maxCorrectionBits</a> = 3;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let&#39;s create a dictionary of 100 markers</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 100; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Assume generateMarkerBits() generates a new marker in binary format, so that</span></div>
<div class="line">    <span class="comment">// markerBits is a 6x6 matrix of CV_8UC1 type, only containing 0s and 1s</span></div>
<div class="line">    <a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a> markerBits = generateMarkerBits();</div>
<div class="line">    <a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a> markerCompressed = <a class="code hl_function" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html#af64929dff16f07347e6a449f48c78ec9">cv::aruco::Dictionary::getByteListFromBits</a>(markerBits);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add the marker as a new row</span></div>
<div class="line">    dictionary.<a class="code hl_variable" href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html#acd75143ec1fe49467dccc67503a66f07">bytesList</a>.<a class="code hl_function" href="../../d3/d63/classcv_1_1Mat.html#af4bd5c2cb936dd363816d867aab22a61">push_back</a>(markerCompressed);</div>
<div class="line">}</div>
<div class="ttc" id="aclasscv_1_1Mat_html_af4bd5c2cb936dd363816d867aab22a61"><div class="ttname"><a href="../../d3/d63/classcv_1_1Mat.html#af4bd5c2cb936dd363816d867aab22a61">cv::Mat::push_back</a></div><div class="ttdeci">void push_back(const _Tp &amp;elem)</div><div class="ttdoc">Adds elements to the bottom of the matrix.</div></div>
<div class="ttc" id="aclasscv_1_1aruco_1_1Dictionary_html_a729196b33a1a678a82f01f8e15d7864b"><div class="ttname"><a href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html#a729196b33a1a678a82f01f8e15d7864b">cv::aruco::Dictionary::maxCorrectionBits</a></div><div class="ttdeci">int maxCorrectionBits</div><div class="ttdoc">maximum number of bits that can be corrected</div><div class="ttdef"><b>Definition</b> aruco_dictionary.hpp:34</div></div>
<div class="ttc" id="aclasscv_1_1aruco_1_1Dictionary_html_a996eb5d27e061fedf0550092a6149ed7"><div class="ttname"><a href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html#a996eb5d27e061fedf0550092a6149ed7">cv::aruco::Dictionary::markerSize</a></div><div class="ttdeci">int markerSize</div><div class="ttdoc">number of bits per dimension</div><div class="ttdef"><b>Definition</b> aruco_dictionary.hpp:33</div></div>
<div class="ttc" id="aclasscv_1_1aruco_1_1Dictionary_html_acd75143ec1fe49467dccc67503a66f07"><div class="ttname"><a href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html#acd75143ec1fe49467dccc67503a66f07">cv::aruco::Dictionary::bytesList</a></div><div class="ttdeci">Mat bytesList</div><div class="ttdoc">marker code information. See class description for more details</div><div class="ttdef"><b>Definition</b> aruco_dictionary.hpp:32</div></div>
<div class="ttc" id="aclasscv_1_1aruco_1_1Dictionary_html_af64929dff16f07347e6a449f48c78ec9"><div class="ttname"><a href="../../d5/d0b/classcv_1_1aruco_1_1Dictionary.html#af64929dff16f07347e6a449f48c78ec9">cv::aruco::Dictionary::getByteListFromBits</a></div><div class="ttdeci">static Mat getByteListFromBits(const Mat &amp;bits)</div><div class="ttdoc">Transform matrix of bits to list of bytes with 4 marker rotations.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1057"></a>
Detector Parameters</h1>
<p>One of the parameters of <code><a class="el" href="../../d2/d1a/classcv_1_1aruco_1_1ArucoDetector.html" title="The main functionality of ArucoDetector class is detection of markers in an image with detectMarkers(...">cv::aruco::ArucoDetector</a></code> is a <code><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html" title="struct DetectorParameters is used by ArucoDetector">cv::aruco::DetectorParameters</a></code> object. This object includes all the options that can be customized during the marker detection process.</p>
<p>This section describes each detector parameter. The parameters can be classified depending on the process in which they’re involved:</p>
<h2><a class="anchor" id="autotoc_md1058"></a>
Thresholding</h2>
<p>One of the first steps in the marker detection process is adaptive thresholding of the input image.</p>
<p>For instance, the thresholded image for the sample image used above is:</p>
<div class="image">
<img src="../../singlemarkersthresh.png" alt=""/>
<div class="caption">
Thresholded image</div></div>
    <p>This thresholding can be customized with the following parameters:</p>
<h3><a class="anchor" id="autotoc_md1059"></a>
adaptiveThreshWinSizeMin, adaptiveThreshWinSizeMax, and adaptiveThreshWinSizeStep</h3>
<p>The <code>adaptiveThreshWinSizeMin</code> and <code>adaptiveThreshWinSizeMax</code> parameters represent the interval where the thresholding window sizes (in pixels) are selected for the adaptive thresholding (see OpenCV <code>threshold()</code> and <code>adaptiveThreshold()</code> functions for more details).</p>
<p>The parameter <code>adaptiveThreshWinSizeStep</code> indicates the increments of the window size from <code>adaptiveThreshWinSizeMin</code> to <code>adaptiveThreshWinSizeMax</code>.</p>
<p>For instance, for the values <code>adaptiveThreshWinSizeMin</code> = 5 and <code>adaptiveThreshWinSizeMax</code> = 21 and <code>adaptiveThreshWinSizeStep</code> = 4, there will be 5 thresholding steps with window sizes 5, 9, 13, 17 and 21. On each thresholding image, marker candidates will be extracted.</p>
<p>Low values of window size can "break" the marker border if the marker size is too large, causing it to not be detected, as in the following image:</p>
<div class="image">
<img src="../../singlemarkersbrokenthresh.png" alt=""/>
<div class="caption">
Broken marker image</div></div>
    <p>On the other hand, too large values can produce the same effect if the markers are too small, and can also reduce the performance. Moreover the process will tend to global thresholding, resulting in a loss of adaptive benefits.</p>
<p>The simplest case is using the same value for <code>adaptiveThreshWinSizeMin</code> and <code>adaptiveThreshWinSizeMax</code>, which produces a single thresholding step. However, it is usually better to use a range of values for the window size, although many thresholding steps can also reduce the performance considerably.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#ac430a508ab62b3ebabd2552b29ea0424" title="minimum window size for adaptive thresholding before finding contours (default 3).">cv::aruco::DetectorParameters::adaptiveThreshWinSizeMin</a>, <a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#ac17bfce78d75a1e8be8657067a974275" title="maximum window size for adaptive thresholding before finding contours (default 23).">cv::aruco::DetectorParameters::adaptiveThreshWinSizeMax</a>, <a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a2470127bdbb23b780696a5234563cf47" title="increments from adaptiveThreshWinSizeMin to adaptiveThreshWinSizeMax during the thresholding (default...">cv::aruco::DetectorParameters::adaptiveThreshWinSizeStep</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1060"></a>
adaptiveThreshConstant</h3>
<p>The <code>adaptiveThreshConstant</code> parameter represents the constant value added in the thresholding operation (see OpenCV <code>threshold()</code> and <code>adaptiveThreshold()</code> functions for more details). Its default value is a good option in most cases.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#aef7291f7771315af9726eafacb7fc955" title="constant for adaptive thresholding before finding contours (default 7)">cv::aruco::DetectorParameters::adaptiveThreshConstant</a></dd></dl>
<h2><a class="anchor" id="autotoc_md1061"></a>
Contour filtering</h2>
<p>After thresholding, contours are detected. However, not all contours are considered as marker candidates. They are filtered out in different steps so that contours that are very unlikely to be markers are discarded. The parameters in this section customize this filtering process.</p>
<p>It must be noted that in most cases it is a question of balance between detection capacity and performance. All the considered contours will be processed in the following stages, which usually have a higher computational cost. So, it is preferred to discard invalid candidates in this stage than in the later stages.</p>
<p>On the other hand, if the filtering conditions are too strict, the real marker contours could be discarded and, hence, not detected.</p>
<h3><a class="anchor" id="autotoc_md1062"></a>
minMarkerPerimeterRate and maxMarkerPerimeterRate</h3>
<p>These parameters determine the minimum and maximum size of a marker, specifically the minimum and maximum marker perimeter. They are not specified in absolute pixel values, instead they are specified relative to the maximum dimension of the input image.</p>
<p>For instance, a image with size 640x480 and a minimum relative marker perimeter of 0.05 will lead to a minimum marker perimeter of 640x0.05 = 32 pixels, since 640 is the maximum dimension of the image. The same applies for the <code>maxMarkerPerimeterRate</code> parameter.</p>
<p>If the <code>minMarkerPerimeterRate</code> is too low, detection performance can be significantly reduced, as many more contours will be considered for future stages. This penalization is not so noticeable for the <code>maxMarkerPerimeterRate</code> parameter, since there are usually many more small contours than big contours. A <code>minMarkerPerimeterRate</code> value of 0 and a <code>maxMarkerPerimeterRate</code> value of 4 (or more) will be equivalent to consider all the contours in the image, however this is not recommended for performance reasons.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#ad0a7fadbc6f9453e4d3777355dcafd51" title="determine minimum perimeter for marker contour to be detected.">cv::aruco::DetectorParameters::minMarkerPerimeterRate</a>, <a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#aa5d26f7b2428a6b9499e33b007c66d5b" title="determine maximum perimeter for marker contour to be detected.">cv::aruco::DetectorParameters::maxMarkerPerimeterRate</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1063"></a>
polygonalApproxAccuracyRate</h3>
<p>A polygonal approximation is applied to each candidate and only those that approximate to a square shape are accepted. This value determines the maximum error that the polygonal approximation can produce (see <code>approxPolyDP()</code> function for more information).</p>
<p>This parameter is relative to the candidate length (in pixels). So if the candidate has a perimeter of 100 pixels and the value of <code>polygonalApproxAccuracyRate</code> is 0.04, the maximum error would be 100x0.04=5.4 pixels.</p>
<p>In most cases, the default value works fine, but higher error values could be necessary for highly distorted images.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a4d77731cb95dcf9bb1cebf82573fc8eb" title="minimum accuracy during the polygonal approximation process to determine which contours are squares....">cv::aruco::DetectorParameters::polygonalApproxAccuracyRate</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1064"></a>
minCornerDistanceRate</h3>
<p>Minimum distance between any pair of corners in the same marker. It is expressed relative to the marker perimeter. Minimum distance in pixels is Perimeter * minCornerDistanceRate.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a7966579df6a68388a45973533b3cd054" title="minimum distance between corners for detected markers relative to its perimeter (default 0....">cv::aruco::DetectorParameters::minCornerDistanceRate</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1065"></a>
minMarkerDistanceRate</h3>
<p>Minimum distance between any pair of corners from two different markers. It is expressed relative to the minimum marker perimeter of the two markers. If two candidates are too close, the smaller one is ignored.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a28b4eb55fe68292541e4272edc4fde86" title="minimum average distance between the corners of the two markers to be grouped (default 0....">cv::aruco::DetectorParameters::minMarkerDistanceRate</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1066"></a>
minDistanceToBorder</h3>
<p>Minimum distance to any of the marker corners to the image border (in pixels). Markers partially occluded by the image border can be correctly detected if the occlusion is small. However, if one of the corners is occluded, the returned corner is usually placed in a wrong position near the image border.</p>
<p>If the position of marker corners is important, for instance if you want to do pose estimation, it is better to discard any markers whose corners are too close to the image border. Elsewhere, it is not necessary.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a93e8229b7d7db81984eb32ef4c1d1f3f" title="minimum distance of any corner to the image border for detected markers (in pixels) (default 3)">cv::aruco::DetectorParameters::minDistanceToBorder</a></dd></dl>
<h2><a class="anchor" id="autotoc_md1067"></a>
Bits Extraction</h2>
<p>After candidate detection, the bits of each candidate are analyzed in order to determine if they are markers or not.</p>
<p>Before analyzing the binary code itself, the bits need to be extracted. To do this, perspective distortion is corrected and the resulting image is thresholded using Otsu threshold to separate black and white pixels.</p>
<p>This is an example of the image obtained after removing the perspective distortion of a marker:</p>
<div class="image">
<img src="../../removeperspective.jpg" alt=""/>
<div class="caption">
Perspective removing</div></div>
    <p>Then, the image is divided into a grid with the same number of cells as the number of bits in the marker. In each cell, the number of black and white pixels are counted to determine the bit value assigned to the cell (from the majority value):</p>
<div class="image">
<img src="../../bitsextraction1.png" alt=""/>
<div class="caption">
Marker cells</div></div>
    <p>There are several parameters that can customize this process:</p>
<h3><a class="anchor" id="autotoc_md1068"></a>
markerBorderBits</h3>
<p>This parameter indicates the width of the marker border. It is relative to the size of each bit. So, a value of 2 indicates the border has the width of two internal bits.</p>
<p>This parameter needs to coincide with the border size of the markers you are using. The border size can be configured in the marker drawing functions such as <code>generateImageMarker()</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#ae216e58b9ef6f52cdd72890ddfc060b0" title="number of bits of the marker border, i.e. marker border width (default 1).">cv::aruco::DetectorParameters::markerBorderBits</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1069"></a>
minOtsuStdDev</h3>
<p>This value determines the minimum standard deviation of the pixel values to perform Otsu thresholding. If the deviation is low, it probably means that all the square is black (or white) and applying Otsu does not make sense. If this is the case, all the bits are set to 0 (or 1) depending on whether the mean value is higher or lower than 128.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#aefb84a734bdcc918e54bb2ff4f17f2f4" title="minimun standard deviation in pixels values during the decodification step to apply Otsu thresholding...">cv::aruco::DetectorParameters::minOtsuStdDev</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1070"></a>
perspectiveRemovePixelPerCell</h3>
<p>This parameter determines the number of pixels (per cell) in the obtained image after correcting perspective distortion (including the border). This is the size of the red squares in the image above.</p>
<p>For instance, let’s assume we are dealing with markers of 5x5 bits and border size of 1 bit (see <code>markerBorderBits</code>). Then, the total number of cells/bits per dimension is 5 + 2*1 = 7 (the border has to be counted twice). The total number of cells is 7x7.</p>
<p>If the value of <code>perspectiveRemovePixelPerCell</code> is 10, then the size of the obtained image will be 10*7 = 70 -&gt; 70x70 pixels.</p>
<p>A higher value of this parameter can improve the bits extraction process (up to some degree), however it can penalize the performance.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a1feac9bd1d3ae9bc1cc48bcf900cf25d" title="number of bits (per dimension) for each cell of the marker when removing the perspective (default 4).">cv::aruco::DetectorParameters::perspectiveRemovePixelPerCell</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1071"></a>
perspectiveRemoveIgnoredMarginPerCell</h3>
<p>When extracting the bits of each cell, the numbers of black and white pixels are counted. In general, it is not recommended to consider all the cell pixels. Instead it is better to ignore some pixels in the margins of the cells.</p>
<p>The reason for this is that, after removing the perspective distortion, the cells’ colors are, in general, not perfectly separated and white cells can invade some pixels of black cells (and vice versa). Thus, it is better to ignore some pixels just to avoid counting erroneous pixels.</p>
<p>For instance, in the following image:</p>
<div class="image">
<img src="../../bitsextraction2.png" alt=""/>
<div class="caption">
Marker cell margins</div></div>
    <p>only the pixels inside the green squares are considered. It can be seen in the right image that the resulting pixels contain a lower amount of noise from neighbor cells. The <code>perspectiveRemoveIgnoredMarginPerCell</code> parameter indicates the difference between the red and the green squares.</p>
<p>This parameter is relative to the total size of the cell. For instance if the cell size is 40 pixels and the value of this parameter is 0.1, a margin of 40*0.1=4 pixels is ignored in the cells. This means that the total number of pixels that would be analyzed in each cell would actually be 32x32, instead of 40x40.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a2a01a662bf4718fe689d0fe23ddec69e" title="width of the margin of pixels on each cell not considered for the determination of the cell bit.">cv::aruco::DetectorParameters::perspectiveRemoveIgnoredMarginPerCell</a></dd></dl>
<h2><a class="anchor" id="autotoc_md1072"></a>
Marker identification</h2>
<p>After the bits have been extracted, the next step is checking whether the extracted code belongs to the marker dictionary and, if necessary, error correction can be performed.</p>
<h3><a class="anchor" id="autotoc_md1073"></a>
maxErroneousBitsInBorderRate</h3>
<p>The bits of the marker border should be black. This parameter specifies the allowed number of erroneous bits in the border, i.e. the maximum number of white bits in the border. It is represented relative to the total number of bits in the marker.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a9d1e50a0e344152d6507e4b276abc281" title="maximum number of accepted erroneous bits in the border (i.e. number of allowed white bits in the bor...">cv::aruco::DetectorParameters::maxErroneousBitsInBorderRate</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1074"></a>
errorCorrectionRate</h3>
<p>Each marker dictionary has a theoretical maximum number of bits that can be corrected (<code>Dictionary.maxCorrectionBits</code>). However, this value can be modified by the <code>errorCorrectionRate</code> parameter.</p>
<p>For instance, if the allowed number of bits that can be corrected (for the used dictionary) is 6 and the value of <code>errorCorrectionRate</code> is 0.5, the real maximum number of bits that can be corrected is 6*0.5=3 bits.</p>
<p>This value is useful to reduce the error correction capabilities in order to avoid false positives.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#aae04d6771833012d13220ba2e85a0b60" title="error correction rate respect to the maximun error correction capability for each dictionary (default...">cv::aruco::DetectorParameters::errorCorrectionRate</a></dd></dl>
<h2><a class="anchor" id="autotoc_md1075"></a>
Corner Refinement</h2>
<p>After markers have been detected and identified, the last step is performing subpixel refinement of the corner positions (see OpenCV <code>cornerSubPix()</code> and <code><a class="el" href="../../de/d67/group__objdetect__aruco.html#gafce26321f39d331bc12032a72b90eda6">cv::aruco::CornerRefineMethod</a></code>).</p>
<p>Note that this step is optional and it only makes sense if the positions of the marker corners have to be accurate, for instance for pose estimation. It is usually a time-consuming step and therefore is disabled by default.</p>
<h3><a class="anchor" id="autotoc_md1076"></a>
cornerRefinementMethod</h3>
<p>This parameter determines whether the corner subpixel process is performed or not and which method to use if it is being performed. It can be disabled if accurate corners are not necessary. Possible values are <code>CORNER_REFINE_NONE</code>, <code>CORNER_REFINE_SUBPIX</code>, <code>CORNER_REFINE_CONTOUR</code>, and <code>CORNER_REFINE_APRILTAG</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#aacfce88ccc0b5b494e002c9d63848760" title="default value CORNER_REFINE_NONE">cv::aruco::DetectorParameters::cornerRefinementMethod</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1077"></a>
cornerRefinementWinSize</h3>
<p>This parameter determines the maximum window size for the corner refinement process.</p>
<p>High values can cause close corners of the image to be included in the window area, so that the corner of the marker moves to a different and incorrect location during the process. Also, it may affect performance. The window size may decrease if the ArUco marker is too small, check <a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#ae132faf9c0907a424247100639342b70" title="Dynamic window size for corner refinement relative to Aruco module size (default 0....">cv::aruco::DetectorParameters::relativeCornerRefinmentWinSize</a>. The final window size is calculated as: min(cornerRefinementWinSize, averageArucoModuleSize*relativeCornerRefinmentWinSize), where averageArucoModuleSize is average module size of ArUco marker in pixels.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a21ff1cd9084c3695bc0b1d043d5b3bca" title="maximum window size for the corner refinement process (in pixels) (default 5).">cv::aruco::DetectorParameters::cornerRefinementWinSize</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1078"></a>
relativeCornerRefinmentWinSize</h3>
<p>Dynamic window size for corner refinement relative to Aruco module size (default 0.3).</p>
<p>The final window size is calculated as: min(cornerRefinementWinSize, averageArucoModuleSize*relativeCornerRefinmentWinSize), where averageArucoModuleSize is average module size of ArUco marker in pixels. In the case of markers located far from each other, it may be useful to increase the value of the parameter to 0.4-0.5. In the case of markers located close to each other, it may be useful to decrease the parameter value to 0.1-0.2.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#ae132faf9c0907a424247100639342b70" title="Dynamic window size for corner refinement relative to Aruco module size (default 0....">cv::aruco::DetectorParameters::relativeCornerRefinmentWinSize</a></dd></dl>
<h3><a class="anchor" id="autotoc_md1079"></a>
cornerRefinementMaxIterations and cornerRefinementMinAccuracy</h3>
<p>These two parameters determine the stop criteria of the subpixel refinement process. The <code>cornerRefinementMaxIterations</code> indicates the maximum number of iterations and <code>cornerRefinementMinAccuracy</code> the minimum error value before stopping the process.</p>
<p>If the number of iterations is too high, it may affect the performance. On the other hand, if it is too low, it can result in poor subpixel refinement.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a65d86818818aee18f8646d2fdb8170d8" title="maximum number of iterations for stop criteria of the corner refinement process (default 30).">cv::aruco::DetectorParameters::cornerRefinementMaxIterations</a>, <a class="el" href="../../d1/dcd/structcv_1_1aruco_1_1DetectorParameters.html#a2641f13e4f8a25403c828eee5c77a8dd" title="minimum error for the stop cristeria of the corner refinement process (default: 0....">cv::aruco::DetectorParameters::cornerRefinementMinAccuracy</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 2 2024 21:52:14 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.9.8
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
