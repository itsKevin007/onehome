<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>OpenCV: Introduction</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
//<![CDATA[
window.MathJax = {
    loader: {load: ['[tex]/ams']},
    tex: {
        packages: {'[+]': ['ams']},
        macros: {
            matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
            fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
            forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
            forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
            vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
            vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
            cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
            distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
            distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
            hdotsfor: ["\\dots", 1],
            mathbbm: ["\\mathbb{#1}", 1],
            bordermatrix: ["\\matrix{#1}", 1]
        },
        processEscapes: false
    }
};
//]]>
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.10.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Introduction</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>OpenCV (Open Source Computer Vision Library: <a href="http://opencv.org">http://opencv.org</a>) is an open-source library that includes several hundreds of computer vision algorithms. The document describes the so-called OpenCV 2.x API, which is essentially a C++ API, as opposed to the C-based OpenCV 1.x API (C API is deprecated and not tested with "C" compiler since OpenCV 2.4 releases)</p>
<p>OpenCV has a modular structure, which means that the package includes several shared or static libraries. The following modules are available:</p>
<ul>
<li><a class="el" href="../../d0/de1/group__core.html">Core functionality</a> (<b>core</b>) - a compact module defining basic data structures, including the dense multi-dimensional array Mat and basic functions used by all other modules.</li>
<li><a class="el" href="../../d7/dbd/group__imgproc.html">Image Processing</a> (<b>imgproc</b>) - an image processing module that includes linear and non-linear image filtering, geometrical image transformations (resize, affine and perspective warping, generic table-based remapping), color space conversion, histograms, and so on.</li>
<li><a class="el" href="../../d7/de9/group__video.html">Video Analysis</a> (<b>video</b>) - a video analysis module that includes motion estimation, background subtraction, and object tracking algorithms.</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html">Camera Calibration and 3D Reconstruction</a> (<b>calib3d</b>) - basic multiple-view geometry algorithms, single and stereo camera calibration, object pose estimation, stereo correspondence algorithms, and elements of 3D reconstruction.</li>
<li><a class="el" href="../../da/d9b/group__features2d.html">2D Features Framework</a> (<b>features2d</b>) - salient feature detectors, descriptors, and descriptor matchers.</li>
<li><a class="el" href="../../d5/d54/group__objdetect.html">Object Detection</a> (<b>objdetect</b>) - detection of objects and instances of the predefined classes (for example, faces, eyes, mugs, people, cars, and so on).</li>
<li><a class="el" href="../../d7/dfc/group__highgui.html">High-level GUI</a> (<b>highgui</b>) - an easy-to-use interface to simple UI capabilities.</li>
<li><a class="el" href="../../dd/de7/group__videoio.html">Video I/O</a> (<b>videoio</b>) - an easy-to-use interface to video capturing and video codecs.</li>
<li>... some other helper modules, such as FLANN and Google test wrappers, Python bindings, and others.</li>
</ul>
<p>The further chapters of the document describe functionality of each module. But first, make sure to get familiar with the common API concepts used thoroughly in the library.</p>
<h1><a class="anchor" id="autotoc_md130"></a>
API Concepts</h1>
<h2><a class="anchor" id="autotoc_md131"></a>
cv Namespace</h2>
<p>All the OpenCV classes and functions are placed into the <code>cv</code> namespace. Therefore, to access this functionality from your code, use the <code>cv::</code> specifier or <code>using namespace cv;</code> directive:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d0/d9c/core_2include_2opencv2_2core_8hpp.html">opencv2/core.hpp</a>&quot;</span></div>
<div class="line">...</div>
<div class="line">cv::Mat H = <a class="code hl_function" href="../../d9/d0c/group__calib3d.html#ga4abc2ece9fab9398f2e560d53c8c9780">cv::findHomography</a>(points1, points2, <a class="code hl_enumvalue" href="../../d9/d0c/group__calib3d.html#ggaf63d4c617c61e03ab502b3c836966150a724159df258a5d7e29410a6a2f4e6c87">cv::RANSAC</a>, 5);</div>
<div class="line">...</div>
<div class="ttc" id="acore_2include_2opencv2_2core_8hpp_html"><div class="ttname"><a href="../../d0/d9c/core_2include_2opencv2_2core_8hpp.html">core.hpp</a></div></div>
<div class="ttc" id="agroup__calib3d_html_ga4abc2ece9fab9398f2e560d53c8c9780"><div class="ttname"><a href="../../d9/d0c/group__calib3d.html#ga4abc2ece9fab9398f2e560d53c8c9780">cv::findHomography</a></div><div class="ttdeci">Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method=0, double ransacReprojThreshold=3, OutputArray mask=noArray(), const int maxIters=2000, const double confidence=0.995)</div><div class="ttdoc">Finds a perspective transformation between two planes.</div></div>
<div class="ttc" id="agroup__calib3d_html_ggaf63d4c617c61e03ab502b3c836966150a724159df258a5d7e29410a6a2f4e6c87"><div class="ttname"><a href="../../d9/d0c/group__calib3d.html#ggaf63d4c617c61e03ab502b3c836966150a724159df258a5d7e29410a6a2f4e6c87">cv::RANSAC</a></div><div class="ttdeci">@ RANSAC</div><div class="ttdoc">RANSAC algorithm.</div><div class="ttdef"><b>Definition</b> calib3d.hpp:448</div></div>
</div><!-- fragment --><p> or : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d0/d9c/core_2include_2opencv2_2core_8hpp.html">opencv2/core.hpp</a>&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="../../d2/d75/namespacecv.html">cv</a>;</div>
<div class="line">...</div>
<div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> H = findHomography(points1, points2, RANSAC, 5 );</div>
<div class="line">...</div>
<div class="ttc" id="aclasscv_1_1Mat_html"><div class="ttname"><a href="../../d3/d63/classcv_1_1Mat.html">cv::Mat</a></div><div class="ttdoc">n-dimensional dense array class</div><div class="ttdef"><b>Definition</b> mat.hpp:812</div></div>
<div class="ttc" id="anamespacecv_html"><div class="ttname"><a href="../../d2/d75/namespacecv.html">cv</a></div><div class="ttdoc">&quot;black box&quot; representation of the file storage associated with a file on disk.</div><div class="ttdef"><b>Definition</b> core.hpp:102</div></div>
</div><!-- fragment --><p> Some of the current or future OpenCV external names may conflict with STL or other libraries. In this case, use explicit namespace specifiers to resolve the name conflicts: </p><div class="fragment"><div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> a(100, 100, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga4a3def5d72b74bed31f5f8ab7676099c">CV_32F</a>);</div>
<div class="line">randu(a, Scalar::all(1), Scalar::all(std::rand()));</div>
<div class="line">cv::log(a, a);</div>
<div class="line">a /= std::log(2.);</div>
<div class="ttc" id="agroup__core__hal__interface_html_ga4a3def5d72b74bed31f5f8ab7676099c"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#ga4a3def5d72b74bed31f5f8ab7676099c">CV_32F</a></div><div class="ttdeci">#define CV_32F</div><div class="ttdef"><b>Definition</b> interface.h:78</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md132"></a>
Automatic Memory Management</h2>
<p>OpenCV handles all the memory automatically.</p>
<p>First of all, std::vector, <a class="el" href="../../d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class">cv::Mat</a>, and other data structures used by the functions and methods have destructors that deallocate the underlying memory buffers when needed. This means that the destructors do not always deallocate the buffers as in case of Mat. They take into account possible data sharing. A destructor decrements the reference counter associated with the matrix data buffer. The buffer is deallocated if and only if the reference counter reaches zero, that is, when no other structures refer to the same buffer. Similarly, when a Mat instance is copied, no actual data is really copied. Instead, the reference counter is incremented to memorize that there is another owner of the same data. There is also the <a class="el" href="../../d3/d63/classcv_1_1Mat.html#a03d2a2570d06dcae378f788725789aa4" title="Creates a full copy of the array and the underlying data.">cv::Mat::clone</a> method that creates a full copy of the matrix data. See the example below: </p><div class="fragment"><div class="line"><span class="comment">// create a big 8Mb matrix</span></div>
<div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> A(1000, 1000, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga30a562691cc5987bc88eb7bb7a8faf2b">CV_64F</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create another header for the same matrix;</span></div>
<div class="line"><span class="comment">// this is an instant operation, regardless of the matrix size.</span></div>
<div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> B = A;</div>
<div class="line"><span class="comment">// create another header for the 3-rd row of A; no data is copied either</span></div>
<div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> C = B.<a class="code hl_function" href="../../d3/d63/classcv_1_1Mat.html#a4b22e1c23af7a7f2eef8fa478cfa7434">row</a>(3);</div>
<div class="line"><span class="comment">// now create a separate copy of the matrix</span></div>
<div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> D = B.<a class="code hl_function" href="../../d3/d63/classcv_1_1Mat.html#a03d2a2570d06dcae378f788725789aa4">clone</a>();</div>
<div class="line"><span class="comment">// copy the 5-th row of B to C, that is, copy the 5-th row of A</span></div>
<div class="line"><span class="comment">// to the 3-rd row of A.</span></div>
<div class="line">B.<a class="code hl_function" href="../../d3/d63/classcv_1_1Mat.html#a4b22e1c23af7a7f2eef8fa478cfa7434">row</a>(5).<a class="code hl_function" href="../../d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77">copyTo</a>(C);</div>
<div class="line"><span class="comment">// now let A and D share the data; after that the modified version</span></div>
<div class="line"><span class="comment">// of A is still referenced by B and C.</span></div>
<div class="line">A = D;</div>
<div class="line"><span class="comment">// now make B an empty matrix (which references no memory buffers),</span></div>
<div class="line"><span class="comment">// but the modified version of A will still be referenced by C,</span></div>
<div class="line"><span class="comment">// despite that C is just a single row of the original A</span></div>
<div class="line">B.<a class="code hl_function" href="../../d3/d63/classcv_1_1Mat.html#ae48d4913285518e2c21a3457017e716e">release</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// finally, make a full copy of C. As a result, the big modified</span></div>
<div class="line"><span class="comment">// matrix will be deallocated, since it is not referenced by anyone</span></div>
<div class="line">C = C.<a class="code hl_function" href="../../d3/d63/classcv_1_1Mat.html#a03d2a2570d06dcae378f788725789aa4">clone</a>();</div>
<div class="ttc" id="aclasscv_1_1Mat_html_a03d2a2570d06dcae378f788725789aa4"><div class="ttname"><a href="../../d3/d63/classcv_1_1Mat.html#a03d2a2570d06dcae378f788725789aa4">cv::Mat::clone</a></div><div class="ttdeci">CV_NODISCARD_STD Mat clone() const</div><div class="ttdoc">Creates a full copy of the array and the underlying data.</div></div>
<div class="ttc" id="aclasscv_1_1Mat_html_a33fd5d125b4c302b0c9aa86980791a77"><div class="ttname"><a href="../../d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77">cv::Mat::copyTo</a></div><div class="ttdeci">void copyTo(OutputArray m) const</div><div class="ttdoc">Copies the matrix to another one.</div></div>
<div class="ttc" id="aclasscv_1_1Mat_html_a4b22e1c23af7a7f2eef8fa478cfa7434"><div class="ttname"><a href="../../d3/d63/classcv_1_1Mat.html#a4b22e1c23af7a7f2eef8fa478cfa7434">cv::Mat::row</a></div><div class="ttdeci">Mat row(int y) const</div><div class="ttdoc">Creates a matrix header for the specified matrix row.</div></div>
<div class="ttc" id="aclasscv_1_1Mat_html_ae48d4913285518e2c21a3457017e716e"><div class="ttname"><a href="../../d3/d63/classcv_1_1Mat.html#ae48d4913285518e2c21a3457017e716e">cv::Mat::release</a></div><div class="ttdeci">void release()</div><div class="ttdoc">Decrements the reference counter and deallocates the matrix if needed.</div></div>
<div class="ttc" id="agroup__core__hal__interface_html_ga30a562691cc5987bc88eb7bb7a8faf2b"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#ga30a562691cc5987bc88eb7bb7a8faf2b">CV_64F</a></div><div class="ttdeci">#define CV_64F</div><div class="ttdef"><b>Definition</b> interface.h:79</div></div>
</div><!-- fragment --><p> You see that the use of Mat and other basic structures is simple. But what about high-level classes or even user data types created without taking automatic memory management into account? For them, OpenCV offers the <a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">cv::Ptr</a> template class that is similar to std::shared_ptr from C++11. So, instead of using plain pointers: </p><div class="fragment"><div class="line">T* ptr = <span class="keyword">new</span> T(...);</div>
</div><!-- fragment --><p> you can use: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr&lt;T&gt;</a> ptr(<span class="keyword">new</span> T(...));</div>
<div class="ttc" id="agroup__core__basic_html_ga6395ca871a678020c4a31fadf7e8cc63"><div class="ttname"><a href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">cv::Ptr</a></div><div class="ttdeci">std::shared_ptr&lt; _Tp &gt; Ptr</div><div class="ttdef"><b>Definition</b> cvstd_wrapper.hpp:23</div></div>
</div><!-- fragment --><p> or: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr&lt;T&gt;</a> ptr = makePtr&lt;T&gt;(...);</div>
</div><!-- fragment --><p> <code>Ptr&lt;T&gt;</code> encapsulates a pointer to a T instance and a reference counter associated with the pointer. See the <a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">cv::Ptr</a> description for details.</p>
<h2><a class="anchor" id="autotoc_md133"></a>
Automatic Allocation of the Output Data</h2>
<p>OpenCV deallocates the memory automatically, as well as automatically allocates the memory for output function parameters most of the time. So, if a function has one or more input arrays (<a class="el" href="../../d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class">cv::Mat</a> instances) and some output arrays, the output arrays are automatically allocated or reallocated. The size and type of the output arrays are determined from the size and type of input arrays. If needed, the functions take extra parameters that help to figure out the output array properties.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d1/d4f/imgproc_2include_2opencv2_2imgproc_8hpp.html">opencv2/imgproc.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d4/dd5/highgui_8hpp.html">opencv2/highgui.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="../../d2/d75/namespacecv.html">cv</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../dc/d89/highgui__qt_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="../../d8/dfe/classcv_1_1VideoCapture.html">VideoCapture</a> cap(0);</div>
<div class="line">    <span class="keywordflow">if</span>(!cap.isOpened()) <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> frame, edges;</div>
<div class="line">    namedWindow(<span class="stringliteral">&quot;edges&quot;</span>, WINDOW_AUTOSIZE);</div>
<div class="line">    <span class="keywordflow">for</span>(;;)</div>
<div class="line">    {</div>
<div class="line">        cap &gt;&gt; frame;</div>
<div class="line">        cvtColor(frame, edges, COLOR_BGR2GRAY);</div>
<div class="line">        GaussianBlur(edges, edges, <a class="code hl_class" href="../../d6/d50/classcv_1_1Size__.html">Size</a>(7,7), 1.5, 1.5);</div>
<div class="line">        Canny(edges, edges, 0, 30, 3);</div>
<div class="line">        imshow(<span class="stringliteral">&quot;edges&quot;</span>, edges);</div>
<div class="line">        <span class="keywordflow">if</span>(waitKey(30) &gt;= 0) <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclasscv_1_1Size___html"><div class="ttname"><a href="../../d6/d50/classcv_1_1Size__.html">cv::Size_</a></div><div class="ttdoc">Template class for specifying the size of an image or rectangle.</div><div class="ttdef"><b>Definition</b> types.hpp:335</div></div>
<div class="ttc" id="aclasscv_1_1VideoCapture_html"><div class="ttname"><a href="../../d8/dfe/classcv_1_1VideoCapture.html">cv::VideoCapture</a></div><div class="ttdoc">Class for video capturing from video files, image sequences or cameras.</div><div class="ttdef"><b>Definition</b> videoio.hpp:731</div></div>
<div class="ttc" id="ahighgui_8hpp_html"><div class="ttname"><a href="../../d4/dd5/highgui_8hpp.html">highgui.hpp</a></div></div>
<div class="ttc" id="ahighgui__qt_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="../../dc/d89/highgui__qt_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition</b> highgui_qt.cpp:3</div></div>
<div class="ttc" id="aimgproc_2include_2opencv2_2imgproc_8hpp_html"><div class="ttname"><a href="../../d1/d4f/imgproc_2include_2opencv2_2imgproc_8hpp.html">imgproc.hpp</a></div></div>
</div><!-- fragment --><p> The array frame is automatically allocated by the <code>&gt;&gt;</code> operator since the video frame resolution and the bit-depth is known to the video capturing module. The array edges is automatically allocated by the cvtColor function. It has the same size and the bit-depth as the input array. The number of channels is 1 because the color conversion code <a class="el" href="../../d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea" title="convert between RGB/BGR and grayscale, color conversions">cv::COLOR_BGR2GRAY</a> is passed, which means a color to grayscale conversion. Note that frame and edges are allocated only once during the first execution of the loop body since all the next video frames have the same resolution. If you somehow change the video resolution, the arrays are automatically reallocated.</p>
<p>The key component of this technology is the <a class="el" href="../../d3/d63/classcv_1_1Mat.html#a55ced2c8d844d683ea9a725c60037ad0" title="Allocates new array data if needed.">cv::Mat::create</a> method. It takes the desired array size and type. If the array already has the specified size and type, the method does nothing. Otherwise, it releases the previously allocated data, if any (this part involves decrementing the reference counter and comparing it with zero), and then allocates a new buffer of the required size. Most functions call the <a class="el" href="../../d3/d63/classcv_1_1Mat.html#a55ced2c8d844d683ea9a725c60037ad0" title="Allocates new array data if needed.">cv::Mat::create</a> method for each output array, and so the automatic output data allocation is implemented.</p>
<p>Some notable exceptions from this scheme are <a class="el" href="../../d2/de8/group__core__array.html#ga51d768c270a1cdd3497255017c4504be" title="Copies specified channels from input arrays to the specified channels of output arrays.">cv::mixChannels</a>, <a class="el" href="../../d1/dd6/classcv_1_1RNG.html#ad26f2b09d9868cf108e84c9814aa682d" title="Fills arrays with random numbers.">cv::RNG::fill</a>, and a few other functions and methods. They are not able to allocate the output array, so you have to do this in advance.</p>
<h2><a class="anchor" id="autotoc_md134"></a>
Saturation Arithmetics</h2>
<p>As a computer vision library, OpenCV deals a lot with image pixels that are often encoded in a compact, 8- or 16-bit per channel, form and thus have a limited value range. Furthermore, certain operations on images, like color space conversions, brightness/contrast adjustments, sharpening, complex interpolation (bi-cubic, Lanczos) can produce values out of the available range. If you just store the lowest 8 (16) bits of the result, this results in visual artifacts and may affect a further image analysis. To solve this problem, the so-called <em>saturation</em> arithmetics is used. For example, to store r, the result of an operation, to an 8-bit image, you find the nearest value within the 0..255 range:</p>
<p class="formulaDsp">
\[I(x,y)= \min ( \max (\textrm{round}(r), 0), 255)\]
</p>
<p>Similar rules are applied to 8-bit signed, 16-bit signed and unsigned types. This semantics is used everywhere in the library. In C++ code, it is done using the <code><a class="el" href="../../db/de0/group__core__utils.html#gab93126370b85fda2c8bfaf8c811faeaf" title="Template function for accurate conversion from one primitive type to another.">cv::saturate_cast</a>&lt;&gt;</code> functions that resemble standard C++ cast operations. See below the implementation of the formula provided above: </p><div class="fragment"><div class="line">I.at&lt;<a class="code hl_typedef" href="../../d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(y, x) = saturate_cast&lt;uchar&gt;(r);</div>
<div class="ttc" id="agroup__core__hal__interface_html_ga65f85814a8290f9797005d3b28e7e5fc"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a></div><div class="ttdeci">unsigned char uchar</div><div class="ttdef"><b>Definition</b> interface.h:51</div></div>
</div><!-- fragment --><p> where cv::uchar is an OpenCV 8-bit unsigned integer type. In the optimized SIMD code, such SSE2 instructions as paddusb, packuswb, and so on are used. They help achieve exactly the same behavior as in C++ code.</p>
<dl class="section note"><dt>Note</dt><dd>Saturation is not applied when the result is 32-bit integer.</dd></dl>
<h2><a class="anchor" id="autotoc_md135"></a>
Fixed Pixel Types. Limited Use of Templates</h2>
<p>Templates is a great feature of C++ that enables implementation of very powerful, efficient and yet safe data structures and algorithms. However, the extensive use of templates may dramatically increase compilation time and code size. Besides, it is difficult to separate an interface and implementation when templates are used exclusively. This could be fine for basic algorithms but not good for computer vision libraries where a single algorithm may span thousands lines of code. Because of this and also to simplify development of bindings for other languages, like Python, Java, Matlab that do not have templates at all or have limited template capabilities, the current OpenCV implementation is based on polymorphism and runtime dispatching over templates. In those places where runtime dispatching would be too slow (like pixel access operators), impossible (generic <code><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">cv::Ptr</a>&lt;&gt;</code> implementation), or just very inconvenient (<code><a class="el" href="../../db/de0/group__core__utils.html#gab93126370b85fda2c8bfaf8c811faeaf" title="Template function for accurate conversion from one primitive type to another.">cv::saturate_cast</a>&lt;&gt;()</code>) the current implementation introduces small template classes, methods, and functions. Anywhere else in the current OpenCV version the use of templates is limited.</p>
<p>Consequently, there is a limited fixed set of primitive data types the library can operate on. That is, array elements should have one of the following types:</p>
<ul>
<li>8-bit unsigned integer (uchar)</li>
<li>8-bit signed integer (schar)</li>
<li>16-bit unsigned integer (ushort)</li>
<li>16-bit signed integer (short)</li>
<li>32-bit signed integer (int)</li>
<li>32-bit floating-point number (float)</li>
<li>64-bit floating-point number (double)</li>
<li>a tuple of several elements where all elements have the same type (one of the above). An array whose elements are such tuples, are called multi-channel arrays, as opposite to the single-channel arrays, whose elements are scalar values. The maximum possible number of channels is defined by the <a class="el" href="../../d1/d1b/group__core__hal__interface.html#ga3de14a42631396fe0480be69d5d2363f">CV_CN_MAX</a> constant, which is currently set to 512.</li>
</ul>
<p>For these basic types, the following enumeration is applied: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> { <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga32b18d904ee2b1731a9416a8eef67d06">CV_8U</a>=0, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga26f5e76cbfb2fd9c2ba6fadc6cc19ce3">CV_8S</a>=1, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#gaf55ae5a94c48cae66b96979877576f12">CV_16U</a>=2, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga9d2ee1a8334733dea7482a47a88e0f87">CV_16S</a>=3, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga4067910fc388075c3ea3aa14393e83b9">CV_32S</a>=4, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga4a3def5d72b74bed31f5f8ab7676099c">CV_32F</a>=5, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga30a562691cc5987bc88eb7bb7a8faf2b">CV_64F</a>=6 };</div>
<div class="ttc" id="agroup__core__hal__interface_html_ga26f5e76cbfb2fd9c2ba6fadc6cc19ce3"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#ga26f5e76cbfb2fd9c2ba6fadc6cc19ce3">CV_8S</a></div><div class="ttdeci">#define CV_8S</div><div class="ttdef"><b>Definition</b> interface.h:74</div></div>
<div class="ttc" id="agroup__core__hal__interface_html_ga32b18d904ee2b1731a9416a8eef67d06"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#ga32b18d904ee2b1731a9416a8eef67d06">CV_8U</a></div><div class="ttdeci">#define CV_8U</div><div class="ttdef"><b>Definition</b> interface.h:73</div></div>
<div class="ttc" id="agroup__core__hal__interface_html_ga4067910fc388075c3ea3aa14393e83b9"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#ga4067910fc388075c3ea3aa14393e83b9">CV_32S</a></div><div class="ttdeci">#define CV_32S</div><div class="ttdef"><b>Definition</b> interface.h:77</div></div>
<div class="ttc" id="agroup__core__hal__interface_html_ga9d2ee1a8334733dea7482a47a88e0f87"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#ga9d2ee1a8334733dea7482a47a88e0f87">CV_16S</a></div><div class="ttdeci">#define CV_16S</div><div class="ttdef"><b>Definition</b> interface.h:76</div></div>
<div class="ttc" id="agroup__core__hal__interface_html_gaf55ae5a94c48cae66b96979877576f12"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#gaf55ae5a94c48cae66b96979877576f12">CV_16U</a></div><div class="ttdeci">#define CV_16U</div><div class="ttdef"><b>Definition</b> interface.h:75</div></div>
</div><!-- fragment --><p> Multi-channel (n-channel) types can be specified using the following options:</p>
<ul>
<li><a class="el" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a> ... <a class="el" href="../../d1/d1b/group__core__hal__interface.html#ga44a3c8b22264a8a3e392d8245b0b1d37">CV_64FC4</a> constants (for a number of channels from 1 to 4)</li>
<li><a class="el" href="../../d1/d1b/group__core__hal__interface.html#ga78c5506f62d99edd7e83aba259250394">CV_8UC(n)</a> ... <a class="el" href="../../d1/d1b/group__core__hal__interface.html#ga4213eb262159eb6da4edf8c9255e8244">CV_64FC(n)</a> or <a class="el" href="../../d1/d1b/group__core__hal__interface.html#gab2ebca36079fd923483abee99d7ff40d">CV_MAKETYPE(CV_8U, n)</a> ... <a class="el" href="../../d1/d1b/group__core__hal__interface.html#gab2ebca36079fd923483abee99d7ff40d">CV_MAKETYPE(CV_64F, n)</a> macros when the number of channels is more than 4 or unknown at the compilation time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><code>#CV_32FC1 == #CV_32F, #CV_32FC2 == #<a class="el" href="../../d1/d1b/group__core__hal__interface.html#ga56e67b727727f2f9b73a4b62f0c4b2b5">CV_32FC(2)</a> == #<a class="el" href="../../d1/d1b/group__core__hal__interface.html#gab2ebca36079fd923483abee99d7ff40d">CV_MAKETYPE(CV_32F, 2)</a></code>, and <code>#<a class="el" href="../../d1/d1b/group__core__hal__interface.html#gab2ebca36079fd923483abee99d7ff40d">CV_MAKETYPE(depth, n)</a> == ((depth&amp;7) + ((n-1)&lt;&lt;3)</code>. This means that the constant type is formed from the depth, taking the lowest 3 bits, and the number of channels minus 1, taking the next <code>log2(CV_CN_MAX)</code> bits.</dd></dl>
<p>Examples: </p><div class="fragment"><div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> mtx(3, 3, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga4a3def5d72b74bed31f5f8ab7676099c">CV_32F</a>); <span class="comment">// make a 3x3 floating-point matrix</span></div>
<div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> cmtx(10, 1, <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga90505db617283cb4ac14f0870ef57021">CV_64FC2</a>); <span class="comment">// make a 10x1 2-channel floating-point</span></div>
<div class="line">                           <span class="comment">// matrix (10-element complex vector)</span></div>
<div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> img(<a class="code hl_class" href="../../d6/d50/classcv_1_1Size__.html">Size</a>(1920, 1080), <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#ga88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>); <span class="comment">// make a 3-channel (color) image</span></div>
<div class="line">                                    <span class="comment">// of 1920 columns and 1080 rows.</span></div>
<div class="line"><a class="code hl_class" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> grayscale(img.size(), <a class="code hl_define" href="../../d1/d1b/group__core__hal__interface.html#gab2ebca36079fd923483abee99d7ff40d">CV_MAKETYPE</a>(img.depth(), 1)); <span class="comment">// make a 1-channel image of</span></div>
<div class="line">                                                        <span class="comment">// the same size and same</span></div>
<div class="line">                                                        <span class="comment">// channel type as img</span></div>
<div class="ttc" id="agroup__core__hal__interface_html_ga88c4cd9de76f678f33928ef1e3f96047"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#ga88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a></div><div class="ttdeci">#define CV_8UC3</div><div class="ttdef"><b>Definition</b> interface.h:90</div></div>
<div class="ttc" id="agroup__core__hal__interface_html_ga90505db617283cb4ac14f0870ef57021"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#ga90505db617283cb4ac14f0870ef57021">CV_64FC2</a></div><div class="ttdeci">#define CV_64FC2</div><div class="ttdef"><b>Definition</b> interface.h:125</div></div>
<div class="ttc" id="agroup__core__hal__interface_html_gab2ebca36079fd923483abee99d7ff40d"><div class="ttname"><a href="../../d1/d1b/group__core__hal__interface.html#gab2ebca36079fd923483abee99d7ff40d">CV_MAKETYPE</a></div><div class="ttdeci">#define CV_MAKETYPE(depth, cn)</div><div class="ttdef"><b>Definition</b> interface.h:85</div></div>
</div><!-- fragment --><p> Arrays with more complex elements cannot be constructed or processed using OpenCV. Furthermore, each function or method can handle only a subset of all possible array types. Usually, the more complex the algorithm is, the smaller the supported subset of formats is. See below typical examples of such limitations:</p>
<ul>
<li>The face detection algorithm only works with 8-bit grayscale or color images.</li>
<li>Linear algebra functions and most of the machine learning algorithms work with floating-point arrays only.</li>
<li>Basic functions, such as <a class="el" href="../../d2/de8/group__core__array.html#ga10ac1bfb180e2cfda1701d06c24fdbd6" title="Calculates the per-element sum of two arrays or an array and a scalar.">cv::add</a>, support all types.</li>
<li>Color space conversion functions support 8-bit unsigned, 16-bit unsigned, and 32-bit floating-point types.</li>
</ul>
<p>The subset of supported types for each function has been defined from practical needs and could be extended in future based on user requests.</p>
<h2><a class="anchor" id="autotoc_md136"></a>
InputArray and OutputArray</h2>
<p>Many OpenCV functions process dense 2-dimensional or multi-dimensional numerical arrays. Usually, such functions take <code><a class="el" href="../../d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class">cv::Mat</a></code> as parameters, but in some cases it's more convenient to use <code>std::vector&lt;&gt;</code> (for a point set, for example) or <code><a class="el" href="../../de/de1/classcv_1_1Matx.html" title="Template class for small matrices whose type and size are known at compilation time.">cv::Matx</a>&lt;&gt;</code> (for 3x3 homography matrix and such). To avoid many duplicates in the API, special "proxy" classes have been introduced. The base "proxy" class is <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">cv::InputArray</a>. It is used for passing read-only arrays on a function input. The derived from InputArray class <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">cv::OutputArray</a> is used to specify an output array for a function. Normally, you should not care of those intermediate types (and you should not declare variables of those types explicitly) - it will all just work automatically. You can assume that instead of InputArray/OutputArray you can always use <code><a class="el" href="../../d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class">cv::Mat</a></code>, <code>std::vector&lt;&gt;</code>, <code><a class="el" href="../../de/de1/classcv_1_1Matx.html" title="Template class for small matrices whose type and size are known at compilation time.">cv::Matx</a>&lt;&gt;</code>, <code><a class="el" href="../../d6/dcf/classcv_1_1Vec.html" title="Template class for short numerical vectors, a partial case of Matx.">cv::Vec</a>&lt;&gt;</code> or <code><a class="el" href="../../dc/d84/group__core__basic.html#ga599fe92e910c027be274233eccad7beb">cv::Scalar</a></code>. When a function has an optional input or output array, and you do not have or do not want one, pass <a class="el" href="../../dc/d84/group__core__basic.html#gad9287b23bba2fed753b36ef561ae7346">cv::noArray()</a>.</p>
<h2><a class="anchor" id="autotoc_md137"></a>
Error Handling</h2>
<p>OpenCV uses exceptions to signal critical errors. When the input data has a correct format and belongs to the specified value range, but the algorithm cannot succeed for some reason (for example, the optimization algorithm did not converge), it returns a special error code (typically, just a boolean variable).</p>
<p>The exceptions can be instances of the <a class="el" href="../../d1/dee/classcv_1_1Exception.html" title="Class passed to an error.">cv::Exception</a> class or its derivatives. In its turn, <a class="el" href="../../d1/dee/classcv_1_1Exception.html" title="Class passed to an error.">cv::Exception</a> is a derivative of <code>std::exception</code>. So it can be gracefully handled in the code using other standard C++ library components.</p>
<p>The exception is typically thrown either using the <code>#<a class="el" href="../../db/de0/group__core__utils.html#ga5b48c333c777666e076bd7052799f891" title="Call the error handler.">CV_Error(errcode, description)</a></code> macro, or its printf-like <code>#CV_Error_(errcode, (printf-spec, printf-args))</code> variant, or using the <a class="el" href="../../db/de0/group__core__utils.html#gaf62bcd90f70e275191ab95136d85906b" title="Checks a condition at runtime and throws exception if it fails.">CV_Assert(condition)</a> macro that checks the condition and throws an exception when it is not satisfied. For performance-critical code, there is <a class="el" href="../../db/de0/group__core__utils.html#gafbcb487cba05bd288dbe18c433de4f6f">CV_DbgAssert(condition)</a> that is only retained in the Debug configuration. Due to the automatic memory management, all the intermediate buffers are automatically deallocated in case of a sudden error. You only need to add a try statement to catch exceptions, if needed: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">// call OpenCV</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="../../d1/dee/classcv_1_1Exception.html">cv::Exception</a>&amp; e)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* err_msg = e.<a class="code hl_function" href="../../d1/dee/classcv_1_1Exception.html#a3c987fe4346b98fe13f39e663e477318">what</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;exception caught: &quot;</span> &lt;&lt; err_msg &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclasscv_1_1Exception_html"><div class="ttname"><a href="../../d1/dee/classcv_1_1Exception.html">cv::Exception</a></div><div class="ttdoc">Class passed to an error.</div><div class="ttdef"><b>Definition</b> core.hpp:115</div></div>
<div class="ttc" id="aclasscv_1_1Exception_html_a3c987fe4346b98fe13f39e663e477318"><div class="ttname"><a href="../../d1/dee/classcv_1_1Exception.html#a3c987fe4346b98fe13f39e663e477318">cv::Exception::what</a></div><div class="ttdeci">virtual const char * what() const CV_OVERRIDE</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md138"></a>
Multi-threading and Re-enterability</h2>
<p>The current OpenCV implementation is fully re-enterable. That is, the same function or the same methods of different class instances can be called from different threads. Also, the same Mat can be used in different threads because the reference-counting operations use the architecture-specific atomic instructions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 2 2024 21:52:13 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.9.8
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
